### HashMap：

​		JDK1.8：数组+链表+红黑树

​		初始容量位16

​		为什么负载因子是0.75而不是其他的？

​		在时间和空间上权衡的结果。如果值较高，例如1，此时会减少空间开销，但是 hash 冲突的概率会增大，增加查找成本；而如果值较低，例如 0.5 ，此时 hash 冲突会降低，但是有一半的空间会被浪费，所以折衷考虑 0.75 似乎是一个合理的值。

​		

hashmap少于8个就转链表，大于8个就转红黑树

​		size：HashMap 已经存储的节点个数

​		threshold:扩容阈值当 HashMap 的个数达到该值，触发扩容

​		loadFactor：负载因子，扩容阈值 = 容量 * 负载因子

​		

​		JDK1.7：数组+链表

###### 	HashMap插入流程:

![f76e2b19b0d1e7a1bf0b27a9ff0daab](http://47.101.69.157:8111/s/zXEjwWMpfwZorFc/preview)

#### 	红黑树原理：

​			1、双叉搜索树的定义

##### 	HashMap优化(JDK1.8)：

​		1.主要优化Hash冲突严重问题;

​		2.计算table初始容量的方式改变。 老的方式是从1开始不断向左位移运算，直接大于等于入参的容器值；新的方式则通过5个移位+或等于运算来计算。

​		3.优化hash值计算方式(简单的让高16位参与运算)

		4. 扩容的插入从头插法改成了尾插法，避免了并发下的死循环
		5. 扩容是计算节点在新表的索引位置方式从“h & (length-1)”改成“hash & oldCap”，性能可能提升不大，但设计更巧妙、更优雅。



​										

