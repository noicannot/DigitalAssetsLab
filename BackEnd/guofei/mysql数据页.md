### 文章的起因：

有一次开会的过程中，大佬问了一个问题：MySQL的主键为什么要设计成自增？

我当时单纯的觉得是聚簇索引的问题，但是下面仔细把这个问题查了一遍，现在把这块的内容简单记录下：

### Q：MySQL的主键为什么要设计成自增？

#### 要回答这个问题首先要清楚一个概念“数据页”。

数据页：其实 MySQL 中进行数据操作的最小单位就是数据页，每个数据页，实际上是默认有16kb的大小。而且这16k大小的空间不单是存放大量的数据行。一个数据页拆分成了很多个部分，大体上来说包含了文件头、数据页头、最小记录和最大记录，多个数据行、空闲空间、数据页目录，文件尾部。

用表格简单汇总一下

| 名称                 | 中文名             | 占用空间 | 简单描述                 |
| -------------------- | ------------------ | -------- | ------------------------ |
| `File Header`        | 文件头部           | `38`字节 | 页的一些通用信息         |
| `Page Header`        | 页面头部           | `56`字节 | 数据页专有的一些信息     |
| `Infimum + Supremum` | 最小记录和最大记录 | `26`字节 | 两个虚拟的行记录         |
| `User Records`       | 用户记录           | 不确定   | 实际存储的行记录内容     |
| `Free Space`         | 空闲空间           | 不确定   | 页中尚未使用的空间       |
| `Page Directory`     | 页面目录           | 不确定   | 页中的某些记录的相对位置 |
| `File Trailer`       | 文件尾部           | `8`字节  | 校验页是否完整           |

其实不需要刻意理解这些每一部分特别具体的含义，而且这每一部分里面存储的数据都是相当复杂，这些数据页其实就跟每一行数据一样，都是由 MySQL 开发人员设计出来的一个特殊的存储格式，就是为了存储每一行数据。

#### 记录在页中的存储

- 当一个记录需要插入页的时候，会从free space划分空间到user recorders
- Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。

#### 记录头信息的秘密

- 预留位1        没有使用
- 预留位2        没有使用
- delete_mask     标记该记录是否被删除
    - 这个属性标记着当前记录是否被删除，占用1个二进制位，值为`0`的时候代表记录并没有被删除，为`1`的时候代表记录被删除掉了
    - 在这里就有一点需要注意，被删除的记录还在页中？是。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的`垃圾链表`，在这个链表中的记录占用的空间称之为所谓的`可重用空间`，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。
- min_rec_mask        B+树的每层非叶子节点中的最小记录都会添加该标记
- n_owned     表示当前记录拥有的记录数,一般是每个页中的每个槽中最大值标识这个槽有几个记录。
- heap_no     表示当前记录在记录堆的位置信息
- record_type     表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录
- next_record     表示下一条记录的相对位置
    - 这个属性非常的重要，表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。
    - 比方说第一条记录的`next_record`值为`32`，意味着从第一条记录的真实数据的地址处向后找`32`个字节便是下一条记录的真实数据。仔细想想这个数据结构是不是特别像链表，可以通过一条记录找到它的下一条记录。
    - 但是需要注意注意再注意的一点是，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。

#### Page Directory（页目录）

**是什么**：

1、将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。

2、每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。

3、将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的Page Directory

4、页面目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页面目录就是由槽组成的。

5、一组对应一个槽

6、对于最小记录所在的分组只能有 1 条记录

7、最大记录所在的分组拥有的记录条数只能在 1~8 条之间

8、剩下的分组中记录的条数范围只能在是 4~8 条之间

##### 如何分组：

1、初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。

2、之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个

3、在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。

##### 数据页中查找指定主键值的记录的过程：

1、通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录

2、通过记录的next_record属性遍历该槽所在的组中的各个记录

#### Page Header（页面头部）

- 记录该页包含多少条记录（包括最小和最大记录以及标记为删除的记录）
- 记录第一条记录的地址（是该页第一条记录）
- 页目录中存储了多少个slot
- 还未使用的空间最小地址,也就是说从该地址之后就是Free Space(比如给了99这个地址，则该页尾部到99都是空闲地址)
- 第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）
- 已删除记录占用的字节数
- 最后插入记录的位置
- 最后一条记录插入的方向（PAGE_DIRECTION）
- 一个方向连续插入的记录数量（PAGE_N_DIRECTION）
- 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）
- 修改当前页的最大事务ID，该值仅在二级索引中定义
- 当前页在B+树中所处的层级
- 索引ID，表示当前页属于哪个索引
- B+树叶子段的头部信息，仅在B+树的Root页定义
- B+树非叶子段的头部信息，仅在B+树的Root页定义

#### File Header（文件头部）

- Page Header是专门针对数据页记录的各种状态信息，而File Header则是对所有类型的数据页都适用
- 页的校验和（checksum值）
    - 检验和的机制在很多存储数据库上都有体现
- 页号
- 上一个页的页号
- 下一个页的页号
- 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）
- 该页的类型
- 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值
- 页属于哪个表空间

#### File Trailer

- 为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况）
- 前4个字节代表页的校验和
- 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）
- File Trailer与File Header类似，都是所有类型的页通用的

上面这几部分我们可以简单了解下，主要是需要清楚他们之间大概做了什么，有什么用。

### 为什么设计成自增？

数据页之间是组成双向链表的，而它内部的数据行又是组成单向链表的，每一个数据页内根据主键做了一个页目录。

现在就要说到为什么主键需要自增（首先清楚一点就是我们说主键设计成自增，只是在性能上来说的，不设计成自增完全可以，比如使用UUID）

回到最初的需求上面，我们往数据库里面插入一条数据，它先是会插入到一个缓存池（Buffer pool）里面，先知道这么个东西，而且这个也是 MySQL 最重要的一个内容，后面会专门记录这点。然后从缓存池里面刷到数据页。但是这个时候会涉及到一个**页分裂**的过程，也就是说，这个表里面是如何出现一个又一个的数据页的。

那这和主键设计成自增又有什么关系呢？

首先又得引入索引这个概念，索引运作的一个核心基础就是要求你后一个数据页的主键值都大于前面一个数据页的主键值，但是如果你的主键是自增的，那还可以保证这一点，因为你新插入后一个数据页的主键值一定都大于前一个数据页的主键值。

如果你的主键不是自增的，就有可能会出现后一个数据页的主键值里，有的主键值是小于前一个数据页的主键值的。

比如在第一个数据页里有一条数据的主键是10，第二个数据页里居然有一条数据的主键值是8，那此时肯定有问题了。

这个时候就会出现**页分裂**，就是万一你的主键值都是你自己设置的，那么在增加一个新的数据页的时候，实际上会把前一个数据页里主键值较大的，挪动到新的数据页里来，然后把你新插入的主键值较小的数据挪动到上一个数据页里去，保证新数据页里的主键值一定都比上一个数据页里的主键值大。

所以基于这个原因，我们在设计主键的时候最好设计成自增的。当然自增主键还有其他的好处，比如提高查询效率，减少内存碎片。但是上面的原因才是最根本的原因----“防止数据页分裂”。

最后需要说清楚一点，我们都是在 InnoDB 的前提下说的这些内容





