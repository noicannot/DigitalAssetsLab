## 为什么会有事务？

一言以蔽之，`多个客户端请求同时请求服务器端，会造成数据不一致情况`

`MySQL`是一个`客户端／服务器`架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（`Session`）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。

## 事务的ACID特性

- #### 原子性（`Atomicity`）

  简单来说，原子性就是要么成功，要么失败，不能有成功一半的中间状态存在。用现实生活中的转账来举例，也就是说要么压根儿就没转，要么转账成功，不能存在中间的状态，也就是转了一半的这种情况。

- #### 隔离性（`Isolation`）

  现实世界中的两次状态转换应该是互不影响的，比如说A向B同时进行的两次金额为5元的转账（假设可以在两个ATM机上同时操作）。那么最后A的账户里肯定会少10元，B的账户里肯定多了10元。但是到对应的数据库世界中，事情又变的复杂了一些。为了简化问题，我们粗略的假设A向B转账5元的过程是由下边几个步骤组成的：

    1. 读取A账户的余额到变量A中，这一步骤简写为`read(A)`
    2. 将A账户的余额减去转账金额，这一步骤简写为`A = A - 5`
    3. 将A账户修改过的余额写到磁盘里，这一步骤简写为`write(A)`
    4. 读取B账户的余额到变量B，这一步骤简写为`read(B)`
    5. 将B账户的余额加上转账金额，这一步骤简写为`B = B + 5`
    6. 将B账户修改过的余额写到磁盘里，这一步骤简写为`write(B)`

  把两次转账表示为T1和T2，在现实生活，T1和T2是没有关系的，也就是说可以先执行完T1，后执行T2。但是对应到数据里面，我们期待的是先执行完T1在执行T2，但是数据库里面有可能执行T1的中就开始执行T2了，这就是会导致最终的数据对不上，这就是没有隔离型带来的危害。这时就需要一些措施来让访问相同数据（上例中的A账户和B账户）的不同状态转换（上例中的`T1`和`T2`）对应的数据库操作的执行顺序有一定规律。

- #### 一致性（`Consistency`）

  现实世界是形象具体的，数据库是抽象的。但是约束却是不变的。举个例子，现实世界中只有男的和女的，现实世界中一周只有七天，现实世界中每个人的身份证号是唯一的等。对应到数据库中依然是成立的。数据库世界只是现实世界的一个映射。现实世界中存在的约束当然也要在数据库世界中有所体现。如果数据库中的数据全部符合现实世界中的约束（all defined rules），就可以说这些数据就是一致的，或者说符合`一致性`的。保证一致性需要靠两反面的努力：

    - 数据库本身能为我们保证一部分一致性需求（就是数据库自身可以保证一部分现实世界的约束永远有效）

      `MySQL`数据库可以为表建立主键、唯一索引、外键、声明某个列为`NOT NULL`来拒绝`NULL`值的插入。比如说当我们对某个列建立唯一索引时，如果插入某条记录时该列的值重复了，那么`MySQL`就会报错并且拒绝插入。除了这些我们已经非常熟悉的保证一致性的功能，`MySQL`还支持`CHECK`语法来自定义约束，但是没用。（SQL Server或者Oracle支持check检查）

    - 更多的一致性需求需要靠写业务代码的程序员自己保证

- #### 持久性（`Durability`）

  当现实世界的一个状态转换完成后，这个转换的结果将永久的保留，这个规则称为`持久性`。比方说A向B转账，当ATM机提示转账成功了，就意味着这次账户的状态转换完成了，B就可以拔卡走人了。如果当B走掉之后，银行又把这次转账操作给撤销掉，恢复到没转账之前的样子，那A不就惨了。所以这个`持久性`是非常重要的。

  当把现实世界的状态转换映射到数据库世界时，`持久性`意味着该转换对应的数据库操作所修改的数据都应该在磁盘上保留下来，不论之后发生了什么事故，本次转换造成的影响都不应该被丢失掉。

## 事务并发遇到的问题

用一张数据库表来解释这几个问题：

```mysql
-- 创建一张 hero 表
CREATE TABLE hero (
    number INT,
    name VARCHAR(100),
    country varchar(100),
    PRIMARY KEY (number)
) Engine=InnoDB CHARSET=utf8;

-- 插入数据
INSERT INTO hero VALUES(1, '刘备', '蜀');

-- 表里数据如下
mysql> SELECT * FROM hero;
+--------+--------+---------+
| number | name   | country |
+--------+--------+---------+
|      1 | 刘备   | 蜀      |
+--------+--------+---------+
1 row in set (0.00 sec)

-- 主键命名为 number ,是为了和后面的某个 mysql 保留参数区分

```



访问相同数据的事务在不保证串行执行的情况下可能会出现的问题：

- #### 脏写（`Dirty Write`）

  如果一个事务`修改`另一个`未提交`事务`修改过`的数据，那就是发生了`脏写`，示意图：

  | 发生时间编号 |                    Session A                    |                    Session B                    |
    | :----------: | :---------------------------------------------: | :---------------------------------------------: |
  |      1       |                     BEGIN;                      |                                                 |
  |      2       |                                                 |                     BEGIN;                      |
  |      3       |                                                 | update hero set name = '关羽' where number = 1; |
  |      4       | update hero set name = '张飞' where number = 1; |                                                 |
  |      5       |                     COMMIT;                     |                                                 |
  |      6       |                                                 |                     COMMIT;                     |

  关于这个流程解释如下：

  `Session A`和`Session B`各开启了一个事务，`Session B`中的事务先将`number`列为`1`的记录的`name`列更新为`'关羽'`，然后`Session A`中的事务接着又把这条`number`列为`1`的记录的`name`列更新为`张飞`。如果之后`Session B`中的事务进行了回滚，那么`Session A`中的更新也将不复存在，这种现象就称之为`脏写`。

  这时`Session A`中的事务就很懵逼，我明明把数据更新了，最后也提交事务了，怎么到最后说自己啥也没干呢？

- #### 脏读（`Dirty Read`）

  如果一个事务读到了另一个未提交事务修改过的数据，那就是发生了`脏读`，示意图：

  | 发生时间编号 |                          Session A                           |                    Session B                    |
    | :----------: | :----------------------------------------------------------: | :---------------------------------------------: |
  |      1       |                            BEGIN;                            |                                                 |
  |      2       |                                                              |                     BEGIN;                      |
  |      3       |                                                              | update hero set name = '关羽' where number = 1; |
  |      4       | Select * from hero where number = 1;(如果读到的name值为‘关羽’，那就是发生了脏读) |                                                 |
  |      5       |                           COMMIT;                            |                                                 |
  |      6       |                                                              |                     COMMIT;                     |

  关于这个流程解释如下：

  `Session A`和`Session B`各开启了一个事务，`Session B`中的事务先将`number`列为`1`的记录的`name`列更新为`'关羽'`，然后`Session A`中的事务再去查询这条`number`为`1`的记录，如果读到列`name`的值为`'关羽'`，而`Session B`中的事务稍后进行了回滚，那么`Session A`中的事务相当于读到了一个不存在的数据，这种现象就称之为`脏读`。

- #### 不可重复读（`Non-Repeatable Read`）

  如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了`不可重复读`，示意图：

  | 发生时间编号 |                          Session A                           |                    Session B                    |
    | :----------: | :----------------------------------------------------------: | :---------------------------------------------: |
  |      1       |                            BEGIN;                            |                                                 |
  |      2       | Select * from hero where number = 1;(此时读到的name值为‘刘备’) |                                                 |
  |      3       |                                                              | update hero set name = '关羽' where number = 1; |
  |      4       | Select * from hero where number = 1;(如果此时读到的name值为‘关羽’，) |                                                 |
  |      5       |                                                              | update hero set name = '张飞' where number = 1; |
  |      6       | Select * from hero where number = 1;(如果此时读到的name值为‘张飞’，发生不可重复读) |                                                 |

  关于这个流程解释如下：

  `Session B`中提交了几个隐式事务（注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了`number`列为`1`的记录的列`name`的值，每次事务提交之后，如果`Session A`中的事务都可以查看到最新的值，这种现象也被称之为`不可重复读`。

  不可重复读是比较抽象的，再举一个例子体会下：

  比如有三个事务（事务A、事务B、事务C），此时事务A开启事务，查询了一条数据，比如就是查到了name的值为刘备，这个时候事务A`还没有提交`，事务B修改了这条数据（修改完就提交事务），将name的值修改为关羽，这个时候事务A读取到的数据变成了关羽。再接着事务C和事务B一样，将这条数据修改为张飞（修改完就提交事务），这个时候事务A读取到这条数据变成了张飞，需要注意的是，此时事务A`还都是没有提交`的。也就是说`一个事务在没有提交之前读取了其他事务修改过已提交的数据`，读取到的数据发生了`变化`（不一致），这就是发生了`不可重复读`（重复读取到的数据是不一致的）。

  需要解释的是关于这个情况需要讨论：不可重复读看起来没有问题，很正常，因为其他事务已经提交了，我读取到的肯定是变化的数据，要不然就是脏读了。但是如果你希望在事务执行期间，读取到的数据`永远是一致`的，那么`不可重复读就是有问题`的。所以其实就是取决于你自己想要数据库是什么样子的：

    1. 如果你希望看到的场景就是不可重复读，也就是事务A在执行多次查询一条数据，每次都可以查到其他已经提交的事务修改过的值，那么就是不可重复读，如果你希望的是这个样子，那就是没有问题的。
    2. 如果你希望的是，假设你事务A刚开始执行，第一次查询到的值是刘备，然后你希望事务执行期间你查到的数据都是刘备，不管其他事务如何更新这个值，哪怕它们都提交了，你依然希望读取到的的值是刘备，那么你希望的就是可重复读，那么不可重读读就是有问题的。

- #### 幻读（`Phantom`）

  如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了`幻读`，示意图：

  | 发生时间编号 |                          Session A                           |               Session B                |
    | :----------: | :----------------------------------------------------------: | :------------------------------------: |
  |      1       |                            BEGIN;                            |                                        |
  |      2       | Select * from hero where number > 0;(此时读到的name值为‘刘备’) |                                        |
  |      3       |                                                              | INSERT INTO hero VALUES(2,'曹操','魏') |
  |      4       | Select * from hero where number > 0;(如果此时读到的name值为‘刘备’,‘曹操’，发生幻读) |                                        |

  关于这个流程解释如下：

  `Session A`中的事务先根据条件`number > 0`这个条件查询表`hero`，得到了`name`列值为`'刘备'`的记录；之后`Session B`中提交了一个隐式事务，该事务向表`hero`中插入了一条新记录；之后`Session A`中的事务再根据相同的条件`number > 0`查询表`hero`，得到的结果集中包含`Session B`中的事务新插入的那条记录，这种现象也被称之为`幻读`。

  如果`Session B`中是删除了一些符合`number > 0`的记录而不是插入新记录，那`Session A`中之后再根据`number > 0`的条件读取的记录变少了，这种现象算不算`幻读`呢？明确说一下，这种现象不属于`幻读`，`幻读`强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。

  那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？其实这相当于对每一条记录都发生了不可重复读的现象。幻读只是重点强调了`读取到了之前读取没有获取到的记录`。

  可以体会到的是这个问题其实都是因为`业务系统会多线程并发`执行，每个线程都会开启一个事务，每个事务都会执行增删查改操作，然后数据库并发执行多个事务，多个事务可能会并发的对缓存页里面的同一批数据进行增删查改操作，于是就是出现脏写、脏读、不可重复读，幻读等问题。本质都是数据库的`事务并发`问题。为了解决这个问题，数据库才设计了事务隔离机制，MVCC多版本隔离机制，锁机制，用一整套的机制来解决事务并发问题。

  ## 隔离级别是做什么的？

  首先对这些因为并发产生的问题按照严重程度排一下序：

  ```
  脏写 > 脏读 > 不可重复读 > 幻读
  ```

  隔离级别是为了解决mysql的性能问题，设立一些隔离级别，隔离级别越低，越严重的问题就有可能发生，当然性能也会越来越好。

    - `READ UNCOMMITTED`：未提交读。也就是可能读取到其他会话中未提交事务修改的数据
    - `READ COMMITTED`：已提交读。只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
    - `REPEATABLE READ`：可重复读。可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
    - `SERIALIZABLE`：可串行化。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

  SQL标准种规定，针对不同的隔离级别，并发事务可以发生不同程度的问题，具体如下：

  |     隔离级别     |     脏读     | **不可重复读** |   **幻读**   |
    | :--------------: | :----------: | :------------: | :----------: |
  | READ UNCOMMITTED |   Possible   |    Possible    |   Possible   |
  |  READ COMMITTED  | Not Possible |    Possible    |   Possible   |
  | REPEATABLE READ  | Not Possible |  Not Possible  |   Possible   |
  |   SERIALIZABLE   | Not Possible |  Not Possible  | Not Possible |

    - `READ UNCOMMITTED`隔离级别下，可能发生`脏读`、`不可重复读`和`幻读`问题。
    - `READ COMMITTED`隔离级别下，可能发生`不可重复读`和`幻读`问题，但是不可以发生`脏读`问题。
    - `REPEATABLE READ`隔离级别下，可能发生`幻读`问题，但是不可以发生`脏读`和`不可重复读`的问题。
    - `SERIALIZABLE`隔离级别下，各种问题都不可以发生。

  `脏写`是怎么回事儿？怎么里边都没写呢？这是因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。

  

  

