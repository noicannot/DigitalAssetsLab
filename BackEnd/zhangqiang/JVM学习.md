# 1、JVM结构
![](https://cdn.nlark.com/yuque/0/2021/jpeg/12668119/1621844039819-158b927c-931e-4a30-9828-d5e9bc9a7a54.jpeg#clientId=u04b81648-9632-4&from=paste&height=474&id=u83c838b6&margin=%5Bobject%20Object%5D&originHeight=474&originWidth=473&originalType=url&ratio=1&status=done&style=none&taskId=u7c5e1ee2-60b7-4437-a46d-912298750b6&width=473)
从上图可知，JVM主要包括四个部分：
1、**类加载器（ClassLoader）**：在JVM启动时或者在类运行时将需要的class加载到JVM中
2、**执行引擎**：负责执行class文件中包括的字节码指令
3、**内存区（运行时数据区）**：在JVM运行的时候操作所分配的内存区。运行时内存区主要可以划分为五个区域，如下图：
![](https://cdn.nlark.com/yuque/0/2021/jpeg/12668119/1621844221979-9ccaf773-a9c9-4c21-98f7-c0510440d528.jpeg#clientId=u04b81648-9632-4&from=paste&height=434&id=u9f75c95c&margin=%5Bobject%20Object%5D&originHeight=434&originWidth=376&originalType=url&ratio=1&status=done&style=none&taskId=uc4675527-10fd-44fc-9d2f-0fc238fbb00&width=376)
方法区（Method Area）：用于存储类结构信息的地方，包括常量池、静态变量、类信息，运行时常量池。虽然JVM规范把方法区描述为堆得一个逻辑部分，但它有个别名non-heap（非堆）。方法区还包含一个运行时常量池（Runtime Constant Pool）。
java堆（Heap）：存储java对象的地方。这块是GC的主要区域。从存储的内容可以知道，方法区和堆是被所有java线程共享的。
java栈（Stack）：java栈总是和线程关联在一起，每当创建一个线程，JVM就会为这个线程创建一个对应的java栈。在这个java栈中又会包含多个栈帧，每运行一个方法就会创建一个栈帧，用于存储局部变量表、操作栈、方法返回值等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在java栈中入栈到出栈的过程。所以java栈是线程私有的。
程序计数器（PC Register）：用于保存当前线程执行的内存地址。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的
本地方法栈（Native Method Stack）：和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。
4、**本地方法接口**：主要是调用C或C++实现的本地方法及返回结果。
# 2、内存分配
JVM虚拟机开始会一次性分配一块较大内存，之后所有的创建操作都会在该块内存上进行分配或释放，这样做的好处是减少了系统的调用，提高性能。
java的内存申请一般分两种，静态内存和动态内存；
静态内存：编译时就可以确定的内存大小，一次性分配不用更改，比如定义的int、String等变量。
动态内存：编译时无法确定内存大小，需要程序运行执行时才能确定内存大小，栈空间、程序计数器和本地方法栈他们都是线程私有的，线程生他们生，线程死他们死，这块不用考虑他们的内存回收，主要考虑方法区和堆空间的内存回收，因为这两个是被所有java线程所共享的而且只有在运行时才知道那些对象和方法是被创建的，所以这些内存的分配和回收都是动态的。
# 3、垃圾检测、回收算法
## 检测垃圾算法：
### 引用计数法：
给对象添加一个计数器，当有其他对象引用就加1，引用失效就减1。（如果有两个对象互相引用，但是这两个对象已经无法访问，此时他们的计数器都不为0，这也是垃圾对象，java中未采用）
### 可达性分析算法（java垃圾回收算法）：
GC root（引用栈空间中本地变量表的对象，引用类静态变量的对象，引用类常量的对象，引用本地方法栈的对象，被同步锁锁住的对象）
通过GC root对象为起点出发向下搜索，搜索走过的路称为引用链，如果一个对象和GC root之间没有引用链，那么就可以判定这个对象已经不可用，可以被回收，但此时对象不会被回收，会先判断该对象是否重写了finalize()方法，没重写或者已经执行过那这个对象就等着被回收，重写了finalize方法还没执行就等该方法执行然后如果对象还是不可达状态就要被回收了，GC标记对象头中的markword
# 4、类加载过程
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载七个阶段。
其中类的加载过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，记载、验证、准备和初始化这四个阶段发生顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语音的运行时绑定。这几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。
## 4.1 Java绑定：
把一个方法的调用与方法所在的类关联起来。
### 4.1.1 静态绑定
程序执行前方法已经被绑定，此时由编译器或其他连接程序实现。针对java，简单地可以理解为程序编译期的绑定。java当中的方法中只有final。static，private和构造方法是静态绑定的。
### 4.1.2 动态绑定
在运行时根据具体对象的额理性进行绑定。在java中，几乎所有方法都是动态绑定。
## 4.2 加载
加载阶段，虚拟机需要完成三件事情：通过一个类的全限定名来获取其定义的二进制字节流、
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构、在java堆中生成一个代表这个类的class对象，作为对方法区中数据的访问入口。
### 4.2.1 类加载器（虚拟机角度）
Java虚拟机的角度来说，只存在两种不同的类加载器
#### 启动类加载器：
使用C++实现（仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。
#### 所有其他的类加载器：
这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。
### 4.2.2 类加载器（开发人员角度）
从开发人员角度来看，类加载器大致可分为三类：
#### 启动类加载器：
与上面相同，一般加载JDK/jre/lib下或被-Xbootclasspath参数指定的路径中，并且能被虚拟机识别的类库。启动类加载器无法被Java程序直接引用
#### 扩展类加载器：
负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器
#### 应用程序类加载器：
该类加载器由sun.misc.Launchaer$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，一般情况下这个就是程序中默认的类加载器。
### 4.2.3 双亲委派模型
| ![image.png](https://cdn.nlark.com/yuque/0/2021/png/12668119/1622442987258-ea7ced99-5b97-419e-bd4c-f7f85c8ca25a.png#clientId=u2f848d58-bf59-4&from=paste&height=433&id=u784b0933&margin=%5Bobject%20Object%5D&name=image.png&originHeight=433&originWidth=213&originalType=binary&ratio=1&size=15593&status=done&style=none&taskId=uacad7414-790e-4c25-ba0b-7239abd90be&width=213) | **概述：**
这种层次关系称为类加载器的双亲委派模型，把每一层上面的类加载器叫做当前层类加载器的父加载器，他们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。
**双亲委派机制说明：**
当一个类加载器收到加载类的请求时，先判断下这个类加载了没，如果加载了就当无事发生，没加载的话就会拿到**父加载器**，然后调用父加载器的加载方法。父加载器同样也会执行这么一套流程，直到到达最顶层启动类加载器，然后没有父类了，就会判断自己是否能加载，不能的话就下沉到子加载器去加载，一直到最底层如果都没有加载器能加载就会抛一个ClassNotFoundException异常。 |
| --- | --- |

**机制好处：**
如果有人想替换系统级别的类：如String.java。篡改他的实现，在这种机制下类已经被启动类加载器加载过了，所以其他类加载器没有机会去加载，防止一定程度的危险代码植入。
## 4.3 验证
验证的目的是为了确保Class文件中的字节流包含信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全，大致分为四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。
### 文件格式验证
验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
### 元数据验证
对类的元数据信息进行语义校验，保证不存在不符合Java语法规范的元数据信息。
### 字节码验证
该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
### 符号引用验证
这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候，主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性校验。
## 4.4 准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。
**注意：**
1、进行内存分配仅包括类变量（static），不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
2、所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false），而不是被在Java代码中显示赋予的值。，如public static final int value =3;，这里就会直接赋值0.
3、如果类字段中存在同时被static和final修饰，那么在准备阶段变量value就会被初始化成所指定的值，如public static final int value =3;，这里就会直接赋值3.
## 4.5 解析
**符号引用**：以一组符号来描述引用到的对象，被引用的对象不一定加载到内存中。
**直接引用**：直接指向目标的指针，被引用的对象必定存在内存中
解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用才去解析他（初始化之后）。
解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。
**类或接口的解析**：判断所要转化成直接引用是对数组类型，还是普通对象类型的引用，从而进行不同的解析。
**字段解析**：对字段进行解析式，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和他们的父接口，还没有则按照继承关系往上递归搜索其父类，直至查找结束。
**类方法解析**：对类方法的解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，在搜索接口。
**接口方法解析**：鱼类方法解析步骤类似，只是接口不会有父类，只递归向上搜索父接口即可。
## 4.6 初始化
初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，在初始化阶段，就是根据程序员主观计划去初始化类变量和其他资源
