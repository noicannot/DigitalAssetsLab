<a name="JsSml"></a>
# jdk8中为什么要加入红黑树？
为了解决hash冲突链化严重影响查询速度，红黑树就是一颗特殊的二叉排序树
<a name="ZBH1l"></a>
# 1、hash理解
把任意长度的输入通过hash算法映射成固定长度的输出<br />**这样会有问题**<br />在程序中可能会碰到两个value值经过hash算法之后算出同样的hash值，也就是会发生hash冲突，**hash冲突无法避免**<br />**好一些的hash算法应该考虑什么点**<br />1、效率要高，要做到长文本也能高效计算出hash值<br />2、hash值不能逆推出原文<br />3、两次输入只要有一点点不同，它也得保证这个hash值是不同的<br />4、尽可能要分散，因为在table中slot大部分都处于空闲状态时要尽可能降低hash冲突
<a name="GPbEk"></a>
# 2、HashMap理解
<a name="QBh8z"></a>
## 结构：
JDK8中hashmap为数组+链表+红黑树组成，每个数据单元都是一个Node结构，Node结构中有key字段、value字段，还有next字段和hash字段（由key的hashcode值二次加工得到，加工公式原hashcode的高16位 ^(异或) 低16位得到一个新值，这么做的原因是hash寻址算法的缘故）<br />1、散列表数组的长度必须是2的次方数<br />2、寻址算法是hash & （table.length -1 ）<br />3、已知table.length一定是2的次方数，length转化为二进制后，一定是1是高位，然后低位都是0，如16转化为二进制就是1加四个0（1 0000），32转化为二进制就是1加五个0（10 0000），如16-1=15转化为二进制就是四个1（1111），任何数与这种高位全部是0，低位都是一串1的数，按位与之后得到的数值一定是大于>=0且<这个二进制数<br />4、高低位异或主要是优化hash算法，因为hashmap内部散列表多数情况下都不会特别大，也就是说table.length - 1得到的这个二进制数，实际有效位也很有限，一般都在低16位以内，这样hash的高16位就等于完全浪费<br />​

，**next字段就是发生hash冲突时，当前桶位中的node与冲突node连成一个链表要用的字段**
<a name="tSsPr"></a>
## 基础知识：
HashMap初始默认长度为16；<br />new HashMap()的时候它不会立即创建，它是一个懒加载机制，在首次put操作时才进行创建<br />**PUT写数据流程：**<br />key的hashcode经过高低位异或之后结果按位与 & (table.length-1)，得到一个槽位下标，然后分四种情况<br />**1、槽位下是空的**<br />这个时候直接把put方法传过来的key和value包装成一个node对象放到这个槽位下就行<br />**2、槽位下有值还没链表化**<br />1、先对比当前值的key和put传过来的key是否相等<br />2、如果完全相等则替换原来key对应的值为新值<br />3、如果不相同就在已有node后面加一个node，采用尾插法<br />**3、槽位下有值已经链表化**<br />与2操作基本一致，不过这次是循环遍历每个值，相同替换，无相同继续尾插追加node，插入完之后再检查一下当前链表是否达到树化阈值（链表长度>=8,hashmap.size>=64）<br />**4、槽位下有值已经红黑树化**<br />1、红黑树从TreeNode说起，它继承了Node结构，在Node基础上加了几个字段，分别是指向父节点parent，指向左子节点left，指向右子节点right，表示颜色属性<br />2、首先找到一个合适的插入点，就是找到插入节点的父节点，找父节点的操作和二叉（排序）树是完全一致的<br />3、二分查找算法映射出来的结构：一颗倒立的二叉树，并且每个节点都可以有子节点，并且左子节点小于根节点，右节点大于根节点，每次向下查找一层就可以排除一半的数据，查找效率非常高。<br />3.1、二分查找情况<br />**查找情况一**：一直向下探测，直到查询到左子树或者右子树为null，说明整个树中，他没有发现，此时就是当前节点插入父节点所在了，插入到父节点的左子树或者是右子树，然后根据这个插入节点的hash值和父节点hash值大小决定左还是右，插入会打破平衡，还需要一个红黑树的平衡算法<br />**查找情况二**：根节点向下探测过程中发现有个节点的key与当前put key完全一致，直接替换<br />**红黑树原则**<br />1、构成树的节点拥有一个颜色属性，颜色要么是黑，要么是红<br />2、根节点必须是黑色的<br />3、从叶节点到根节点的路径上，它每条路径黑色节点一定是一致的<br />4、不能有两个红色节点相连，可以推导出红色节点的两个子节点一定是黑色节点<br />5、叶子节点一定是黑色的<br />6、一定是红插，新的节点一定是红色的，红插有优势，碰到父节点是黑色的话，树不会失衡，黑插树一定失衡<br />​

1、每个节点要么是红色，要么是黑色，但根节点永远是黑色的；<br />2、每个红色节点的两个子节点一定都是黑色；<br />​

3、红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）；<br />​

4、从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；<br />​

5、所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；<br />[

](https://blog.csdn.net/weixin_50236329/article/details/109115620)
<a name="x54de"></a>
# 3、树结构调整方式
当hashmap进行插入或删除操作时，树的结构会发生变化，红黑树的条件可能会被破坏，需要通过调整重新符合红黑树的条件。
<a name="TGF4f"></a>
## 3.1、 左旋
左旋的过程是将 p 的右子树绕 p 逆时针旋转，使得 p 的右子树成为 p 的父亲，同时修改相关节点的引用，使左子树的深度加 1，右子树的深度减 1，通过这种做法来调整树的稳定性。过程如下<br />![](https://cdn.nlark.com/yuque/0/2021/png/12668119/1621420990539-26394dca-e0d5-433f-8d1c-d9bbb2e8bdb3.png#clientId=ue236d5ff-5fae-4&from=paste&height=603&id=uc32947c4&margin=%5Bobject%20Object%5D&originHeight=603&originWidth=1080&originalType=url&status=done&style=none&taskId=u0b5fe3ce-b766-4681-aec8-44866390322&width=1080)<br />

