<a name="lzBNi"></a>
## 一 . 对象的组成
对象头：markword 8个字节  klass pointer 压缩后4个字节，不压缩8个字节<br />markword内含锁信息也就是锁状态无锁、偏向锁、轻量级锁、自旋锁、重量级锁(锁定对象其实就是更改这个对象的markword)还有GC标记信息和hashCode<br />对象实例：不同类型占用字节不同<br />占位填充：64位虚拟机对齐是8个字节，如果对象头加对象实例的大小不为8的倍数，则剩余部分将由占位填充代替达到8的倍数<br />synchronized主要影响的是markword
<a name="kJl0M"></a>
### 对象的创建过程
1、先申请内存<br />2、给对象中实例赋值默认值0，构造方法赋值初始值<br />3、把栈空间对象名称和堆空间中对象初始化空间建立连接
<a name="PxOC4"></a>
## 二 . 锁概念
<a name="4015b"></a>
### CAS操作：
CAS:Compare and Swap, 翻译成比较并交换。<br />1、CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。<br />2、CAS采用的是一种非阻塞算法（nonblocking algorithms），一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。<br />3、CAS通过调用JNI的代码实现Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。JNI:Java Native Interface为JAVA本地调用，允许java调用其他语言
<a name="WJ8V6"></a>
### 自旋锁

- 背景：互斥同步对性能最大的影响是阻塞，挂起和恢复线程都需要转入内核态中完成；并且通常情况下，共享数据的锁定状态只持续很短的一段时间，为了这很短的一段时间进行上下文切换并不值得。
- 原理：当一条线程需要请求一把已经被占用的锁时，并不会进入阻塞状态，而是继续持有CPU执行权等待一段时间，该过程称为『自旋』。
- 优点：由于自旋等待锁的过程线程并不会引起上下文切换，因此比较高效；
- 缺点：自旋等待过程线程一直占用CPU执行权但不处理任何任务，因此若该过程过长，那就会造成CPU资源的浪费。
- 自适应自旋：自适应自旋可以根据以往自旋等待时间的经验，计算出一个较为合理的本次自旋等待时间。



<a name="IDTTn"></a>
### 轻量级锁

- 本质：使用CAS取代互斥同步。
- 背景：『轻量级锁』是相对于『重量级锁』而言的，而重量级锁就是传统的锁。
- 轻量级锁与重量级锁的比较：  
   - 重量级锁是一种悲观锁，它认为总是有多条线程要竞争锁，所以它每次处理共享数据时，不管当前系统中是否真的有线程在竞争锁，它都会使用互斥同步来保证线程的安全；
   - 而轻量级锁是一种乐观锁，它认为锁存在竞争的概率比较小，所以它不使用互斥同步，而是使用CAS操作来获得锁，这样能减少互斥同步所使用的『互斥量』带来的性能开销。
- 实现原理：  
   - 对象头称为『Mark Word』，虚拟机为了节约对象的存储空间，对象处于不同的状态下，Mark Word中存储的信息也所有不同。
   - Mark Word中有个标志位用来表示当前对象所处的状态。
   - 当线程请求锁时，若该锁对象的Mark Word中标志位为01（未锁定状态），则在该线程的栈帧中创建一块名为『锁记录』的空间，然后将锁对象的Mark Word拷贝至该空间；最后通过CAS操作将锁对象的Mark Word指向该锁记录；
   - 若CAS操作成功，则轻量级锁的上锁过程成功；
   - 若CAS操作失败，再判断当前线程是否已经持有了该轻量级锁；若已经持有，则直接进入同步块；若尚未持有，则表示该锁已经被其他线程占用，此时轻量级锁就要膨胀成重量级锁。
- 前提：**轻量级锁比重量级锁性能更高的前提是，在轻量级锁被占用的整个同步周期内，不存在其他线程的竞争。若在该过程中一旦有其他线程竞争，该轻量级锁开始进行自旋等待阶段，如果自旋超过10次那么就会膨胀成重量级锁，如果太多线程进行自旋操作消耗CPU过大，不如升级为重量级锁进入队列等待(不消耗CPU)**！
<a name="QuPWx"></a>
### 偏向锁

- 作用：偏向锁是为了消除无竞争情况下的同步原语，进一步提升程序性能。
- 与轻量级锁的区别：轻量级锁是在无竞争的情况下使用CAS操作来代替互斥量的使用，从而实现同步；而偏向锁是在无竞争的情况下完全取消同步。
- 与轻量级锁的相同点：它们都是乐观锁，都认为同步期间不会有其他线程竞争锁。
- 原理：**偏向锁有个延时，默认4秒后启动，因为JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时已知会有竞争，如果使用偏向锁，就会造成不断地进行锁撤销和锁升级的操作，效率较低，**当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束**(需进行锁撤销操作消耗性能)**，进入轻量级锁的状态，当明确知道会有多个线程竞争时直接升级为轻量级锁。
- 优点：偏向锁可以提高有同步但没有竞争的程序性能。但是如果锁对象时常被多条线程竞争，那偏向锁就是多余的。
- 偏向锁可以通过虚拟机的参数来控制它是否开启。


<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/12668119/1617603691367-a5d4c74e-b45a-4fcf-a738-674b04c1dba3.png#height=386&id=n9W6s&margin=%5Bobject%20Object%5D&name=image.png&originHeight=386&originWidth=759&originalType=binary&size=182883&status=done&style=none&width=759)
<a name="XoicA"></a>
## 三 . 锁升级
<a name="OAKzL"></a>
### 2.1 用户态和内核态
早期JDK，synchronized叫做重量级锁，因为申请锁资源必须通过内核，系统调用​<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/12668119/1617372628148-34f6b400-fb2e-4296-aff3-2a7d552e7f83.png#height=438&id=uuOFi&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=808&originalType=binary&size=80372&status=done&style=none&width=808)
<a name="w2253"></a>
## 四 . Double Check Lock(DCL单例)
在单例模式下多线程访问对象提供的创建对象方法中，首先判断该对象是否为空，若为空则获取锁创建对象，假设一个线程过了判断对象为空的条件之后休眠，另一个线程过来获取锁完成创建对象并释放锁，此时休眠的对象醒来继续获取锁又创建了一个新的对象，所以需要在获取锁之后再判断一下该对象是否为空，**单例对象要加volatile关键字，变量可见性**<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/12668119/1617760623417-5b84f334-447e-45e7-8578-d39976b547d5.png#height=307&id=FfuQl&margin=%5Bobject%20Object%5D&name=image.png&originHeight=307&originWidth=511&originalType=binary&size=51316&status=done&style=none&width=511)
<a name="rXyQc"></a>
## 五 . volatile
<a name="SzXLp"></a>
### 1、 保证变量的可见性：
当一个被volatile关键字修饰的变量被一个线程修改的时候，其他线程可以立刻得到修改之后的结果。当一个线程向被volatile关键字修饰的变量写入数据的时候，虚拟机会强制它被值刷新到主内存中。当一个线程用到被volatile关键字修饰的值的时候，虚拟机会强制要求它从主内存中读取。
<a name="wDpsd"></a>
### 2、 屏蔽指令重排序：
指令重排序是编译器和处理器为了高效对程序进行优化的手段，它只能保证程序执行的结果时正确的，但是无法保证程序的操作顺序与代码顺序一致。这在单线程中不会构成问题，但是在多线程中就会出现问题。非常经典的例子是在单例方法中同时对字段加入voliate，就是为了防止指令重排序。
<a name="RmRov"></a>
#### 2.1、JSR内存屏障
LoadLoad屏障：<br />两条读指令在CPU执行时顺序不能互换<br />StoreStore屏障<br />两条写指令在CPU执行时顺序不能互换<br />LoadStore屏障<br />两条读写指令在CPU执行时顺序不能互换<br />StoreLoad屏障<br />两条写读指令在CPU执行时顺序不能互换
