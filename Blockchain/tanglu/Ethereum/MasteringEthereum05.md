# 《精通以太坊》

## 密钥，地址
以太坊的基础技术之一是密码学cryptography。
加密用来证明秘密的知识而不泄露该秘密（数字签名）
证明数据的真实性（数字指纹）
以太坊的通信和交易数据没有加密，也不需要加密以保护系统。
本章，以密钥和地址的形式介绍一些以太坊用来控制资金所有权的密码学。

#### 简介

以太坊有两种不同类型的账户，可以拥有和控制ether：外部所有账户（EOA）和合同。
本节，研究使用密码学来确定外部所有账户（即私人密钥）对ether的所有权。

EOAs中以太的所有权通过数字密钥digital keys，以太坊地址和数字签名建立。数字密钥由用户创建并存储在文件或称为钱包的简单数据库中。

以太坊交易需要将有效的数字签名包含在区块链中，任何拥有该密钥副本的人都可以控制ether。以太坊交易中的数字签名证明了资金的真正所有者。

数字密钥成对组成，密钥和公钥。以太坊用户很少看到这些数字密钥。在大多数情况下，它们存储在钱包文件内并由以太坊钱包软件管理。

在大多数情况下，以太坊地址是从公钥生成并对应的。但是，并非所有以太坊地址都代表公钥。他们也可以代表合同。

首先，介绍密码学并解释以太坊使用的数学。接下来，介绍密钥是如何生成，存储和管理的。最后，回顾用于表示私钥和公钥以及地址的各种编码格式。

#### 公钥密码技术和加密货币
公钥密码系统使用唯一的密钥来保护信息。基于数学函数，密码学能够创建数字密钥和不可伪造的数字签名，这些签名由数学定律保证。

例如，计算两个大素数的乘积是微不足道的。但是给定两个大素数的乘积，很难找到这两个素数（称为素因式分解问题）。

如果知道一些秘密信息，这些数学函数可以很容易地被反转。比如提供数字6895601，并告诉你一个主素数是1931，可以简单地用一个简单的除法找到另一个：6895601/1931=3571。这样的函数被称为trapdoor函数。

在密码学中有用的另一类数学函数基于椭圆曲线上的算术运算。在椭圆曲线算术中，乘以模数是简单的，但是除法是不可能的（一个被称为离散对数的问题）。是以太坊（和其他加密货币）数字密钥和数字签名的基础。
密钥对由私钥和唯一公钥组成，并且被认为是"一对儿"。公钥用于接收资金，私钥用于创建数字签名来签署交易以支付资金。数字签名也可用于验证合同的所有者或用户。
公钥和私钥之间存在数学关系，允许私钥用于在消息上生成签名。该签名可以在不公开私钥的情况下使用公钥进行验证。
通过公钥和签名，以太坊系统中的每个人都可以独立验证并接受交易的有效性，从而确认在转移ether的人拥有他们。

Tip  在大多数钱包实现中，私钥和公钥一起存储为keypair。但是，公钥可以由私钥进行简单计算，因此只存储私钥也是可以的。

非对称密码术的有用特性是产生数字签名的能力。私钥可应用产生交易的数字签名。这个签名只能由知道私钥的人制作。

#### 私钥
私钥只是一个随机选取的数字。通过证明交易中使用的资金的所有权，私钥用于创建花费ether所需的签名。私钥必须备份防止丢失。

Tip 以太坊私钥只是一个数字。可以使用硬币，铅笔和纸随机挑选你的私钥，256个二进制数字作为私钥。然后可以从私钥生成公钥和地址。

##### 从随机数生成私钥
生成密钥的第一步也是最重要的一步是找到一个安全的熵源或随机源。创建以太坊私钥基本上与选择1到2的256次方之间的数字相同。以太坊软件使用底层操作系统的随机数生成器生成256位熵（随机性）。

私钥可以是1和n-1之间的任何数字，其中n是定义为使用的椭圆曲线的阶数的常数（n=1.158* 10的77次方，略小于2的256次方）。在编程方面，这通常是通过将从密码学安全的随机源收集的更大的随机比特串提供给256位哈希算法，产生一个256位数字。

Tip 以太坊的私人密钥空间的大小（2的256次方）是一个难以置信的大数目。十进制大约是10的77次方。可见宇宙估计含有10的80原子。

#### 公钥
以太坊公钥是一个椭圆曲线上的点point，意思是它是一组满足椭圆曲线方程的x和y坐标。
以太坊公钥是两个数字，并联在一起。这些数字是通过一次单向的计算从私钥生成的。
有很多工具和库会为你做数学。

Tip 椭圆曲线乘法是密码学家称之为“单向”函数的一种函数：在一个方向（乘法）很容易完成，而在相反方向（除法）不可能完成。私钥的所有者可以很容易地创建公钥，然后与世界共享，因为知道没有人能够反转该函数并从公钥计算私钥。这种数学技巧成为证明以太坊资金所有权和合同控制权的不可伪造和安全数学签名的基础。

#### 生成一个公钥
k* G的乘法相当于重复加，G+G+G+...+G，重复k次。总而言之，为了从私钥k生成公钥K，我们将生成点G添加到自己k次。
我们应用这个计算找到我们在私钥中给出的特定私钥的公钥：
Example private key to public key calculation
  K=f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315* G
密码库可以帮助我们使用椭圆曲线乘法计算K值。得到的公钥K被定义为一个点K=（x，y）：
K=（x，y）
where，

x=6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b
y=83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0

在以太坊中，你可以看到公钥以66个十六进制字符（33字节）的十六进制序列表示。这是从行业联盟标准高效密码组（SECG）提出的标准序列化格式采用的。该标准定义了四个可用于识别椭圆曲线上点的可能前缀：

Prefix  Meaning             Length(bytescountingprefix)
0x00   Point at Infinity                        1
0x04   Uncompressed Point                 65
0x02   Compressed Point with evenY     33
0x03   Compressed Point with odd Y     33

以太坊只使用未压缩的公钥，因此唯一相关的前缀是（十六进制）04。

#### 椭圆曲线库
加密货币相关项目中使用了secp256k1椭圆曲线的几个实现：
**OpenSSL**
OpenSSL库提供了一套全面的加密原语，包括secp256k1的完整实现。例如，要派生公钥，可以使用函数+EC_POINT_mul()+。

**libsecp256k1**
Bitcoin Core的libsecp256k1是secp256k1椭圆曲线和其他密码原语的C语言实现。椭圆曲线密码学的libsecp256是从头开始编写的，代替了Bitcoin Core软件中的OpenSSL，在性能和安全性方面被认为是优越的。

#### 加密哈希函数
加密哈希函数在整个以太坊使用。

在本节中，我们将讨论哈希函数，了解它们的基本属性以及这些属性如何使它们在现代密码学的很多领域如此有用。哈希函数是将以太坊公钥转换成地址的一部分。
简而言之，“哈希函数是可用于将任意大小的数据映射到固定大小的数据的函数。”Source：Wikipedia。哈希函数的输入称为原象pre-image或消息message。输出被称为哈希hash或摘要digest。哈希函数的一个特殊子类别是加密哈希函数，它具有对密码学有用的特定属性。

加密哈希函数是一种单向哈希函数，它将任意大小的数据映射到固定大小的位串，如果知道输出，计算上不可能重新创建输入。确定输入的唯一方法是对所有可能的输入进行蛮力搜索，检查匹配输出。

加密哈希函数有五个主要属性：
**确定性**
任何输入消息总是产生相同的哈希摘要。
**可验证性**
计算消息的哈希是有效的（线性性能）。
**不相关**
对消息的小改动（例如，一位改变）会大幅改变哈希输出，以致它不能与原始消息的哈希相关联。
**不可逆性**
从哈希计算消息是不可行的，相当于通过可能的消息进行蛮力搜索。
**碰撞保护**
计算两个不同的消息产生相同的哈希输出应该是不可行的。
碰撞保护对于防止以太坊中的数字签名伪造至关重要。

这些属性的组合使加密哈希函数可用于广泛的安全应用程序，包括：
* 数据指纹识别
* 消息完整性（错误检测）
* 工作证明
* 认证（密码哈希和密钥扩展）
* 伪随机数发生器
* 原象承诺
* 唯一标识符

#### 以太坊的加密哈希函数-Keccak-256
Keccak-256被设计为于2007年举行的SHA-3密码哈希函数竞赛的候选者。在2015年被标准化为FIPS（联邦信息处理标准）202。

Warning 虽然你可能在Ethereum文档和代码中看到“SHA3”，但很多这些实例实际上是指Keccak-256，而不是最终确定的FIPS-202 SHA-3标准。实现差异很小，与填充参数有关，但它们的重要性在于Keccak-256在给定相同输入的情况下产生与FIPS-202 SHA-3不同的哈希输出。

由于Ethereum中使用的哈希函数（Keccak-256）与最终标准（FIP-202 SHA-3）之间的差异造成了混淆，因此正在努力将代码中所有的sha3的所有实例，操作码和库重新命名为keccak256。

#### 我正在使用哪个哈希函数？
判断使用的软件库是FIPS-202 SHA-3还是Keccak-256（如果两者都可能被称为“SHA3”）？
简单方法是使用_test vector_，一个给定输入的预期输出。最常用于哈希函数的测试是_empty input_。如果你使用空字符串作为输入运行哈希函数，你应该看到以下结果：
Testing whether the SHA3 library you are using is Keccak-256 of FIP-202 SHA-3
  Keccak256("")=
c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470
 SHA3("")=
a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a
因此，无论调用什么函数，都可以通过运行上面的简单测试来测试它是否是原始的Keccak-256或最终的NIST标准FIPS-202 SHA-3。请记住，以太坊使用Keccak-256，尽管它在代码中通常被称为SHA-3。

 Ethereum中Keccak-256的第一个应用，即从公钥生成以太坊地址。
 #### 以太坊地址
 以太坊地址是唯一标识符unique identifiers，它们是使用单向哈希函数（Keccak-256）从公钥或合约派生的。
 使用Keccak-256来计算这个公钥的_hash_：
 Keccak256（K）=2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9
 然后我们只保留最后的20个字节（大端序中的最低有效字节），这是我们的以太坊地址： 
001d3f1ef827552ae1114027bd3ecf1f086ba0f9
大多数情况下，你会看到带有前缀“0x”的以太坊地址，表明它是十六进制编码，如下所示：
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9

#### 以太坊地址格式
以太坊地址是十六进制数字，从公钥的Keccak-256哈希的最后20个字节导出的标识符。
与在所有客户端的用户界面中编码的比特币地址不同，它们包含内置校验和来防止输入错误的地址，以太坊地址以原始十六进制形式呈现，没有任何校验和。
该决定背后的基本原理是，以太坊地址最终会隐藏在系统高层的抽象（如名称服务）之后，并且必要时应在较高层添加校验和。
##### 互换客户端地址协议Inter Exchange Clinet Address Protocol（ICAP）
互换客户端地址协议（ICAP）是一种部分与国际银行账号（IBAN）编码兼容的以太坊地址编码，为以太坊地址提供多功能，校验和互操作编码。ICAP地址可以编码以太坊地址或通过以太坊名称注册表注册的常用名称。
IBAN是识别银行账号的国际标准，主要用于电汇。IBAN是一项集中和严格监管的服务。ICAP是以太坊地址的分散但兼容的实现。
一个IBAN由含国家代码，校验和银行账户标识符（特定国家）的34个字母数字字符（不区分大小写）组成。
ICAP使用相同的结构，通过引入代表Ethereum的非标准国家代码XE，后面跟着两个字符的校验和以及3个可能的账户标识符变体：
**Direct**
最多30个字母数字字符big-endian base-36整数，表示以太坊地址的最低有效位。由于此编码适合小于155位，因此它仅适用于以一个或多个零字节开头的以太坊地址。就字段长度和校验和而言，它的优点是它与IBAN兼容。示例：
XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD(33个字符长)
**Baasic**
与“Direct”编码相同，只是长度为31个字符。这使它可以编码任何以太坊地址，但使其与IBAN字段验证不兼容。示例：XE18CHDJBPLTBCJ03FE9O2NS0BPOJVQCU2P(35个字符长)
**Indrect**
编码通过名称注册表提供程序解析为以太坊地址的标识符。使用由asset identifier（例如ETH），名称服务（例如XREG）和9个字符的名称（例如KITTYCATS）组成的16个字母数字字符，这是一个人类可读的名称。示例：XE##ETHXREGKITTYCATS(20个字符长)，其中“##”应由两个计算校验和字符替换。
以太坊地址以零字节开始，因此可以使用IBAN格式中有效的“Direct”ICAP编码方法进行编码。因为它是33个字符长。
如果地址不是从零开始，那么它将被编码为“Basic”编码，这将是35个字符长并且作为IBAN格式无效。
Tip  以零字节开始的任何以太坊地址的概率是1/256。为了生成这样一个类型，在我们找到一个作为IBAN兼容的Direct编码之前，它将平均用256个不同的随机私钥进行256次尝试ICAP地址。
##### 使用大写校验和的十六进制编码（EIP-55）
由于ICAP或名称服务部署缓慢，因此提出了一个新的标准，以太坊改进建议55（EIP-55）。
通过修改十六进制地址的大小写，EIP-55为以太坊地址提供了向后兼容和校验和。
通过修改地址中字母字符的大小写，我们可以传达一个校验和，可以用来保护地址完整性，防止输入或读取错误。不支持EIP-55校验和的钱包简单地忽略地址包含混合大写的事实。但那些支持它的人可以验证它并以99.986%的准确度检测错误。
混合大小写编码很微妙，最初你可能不会注意到它。我们的示例地址是：
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
使用EIP-55混合大小写校验和，它变为：
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9

EIP-55实施起来相当简单。我们采用小写十六进制地址的Keccak-256哈希。这个哈希作为地址的数字指纹，给我们一个方便的校验和。输入（地址）中的任何小改动都会导致哈希结果（校验和）发生很大变化，从而使我们能够有效地检测错误。然后我们的地址的哈希被编码为地址本身的大写字母。一步步分解它：
1.计算小写地址的哈希，不带0x前缀：
Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0f9")

23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9695d9a19d8f673ca991deae1

2.如果哈希的相应十六进制数字大于或等于0x8，则将每个字母地址字符大写。如果我们排列地址和哈希，这将更容易显示：
Address：001d3f1ef827552ae1114027bd3ecf1f086ba0f9
Hash:
23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...

我们的地址在第四个位置包含一个字母d。哈希的第四个字符是6，小于8。所以，我们保持d小写。我们地址中的下一个字母字符是f，位于第六位。十六进制哈希的第六个字符是c，它大于8。因此，我们在地址中大写F，等等。

Address: 001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...

##### 在EIP-55编码地址中检测错误
EIP-55地址如何帮助我们发现错误。假设我们已经打印出ETHER-E编码的以太坊地址：
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9

现在，让我们在阅读该地址时犯一个基本错误。最后一个字符之前的字符是大写字母“F”。对于这个例子，我们假设我们误解为大写“E”。我们在钱包中输入（不正确的地址）：
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0E9

幸运的是，我们的钱包符合EIP-55标准！它注意到混合大写字母并试图验证地址。它将其转换为小写，并计算校验和哈希值：
Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0e9")
5429b5d9460122fb4b11af9cb88b7bb76d8928862e0a57d46dd18dd8e08a6927

如你所见，即使地址只改变了一个字符（事实上，“e”和“f”只相隔1位），地址的哈希值已经根本改变了。这是哈希函数的特性，使它们对校验和非常有用！

现在，让我们排列这两个并检查大小写：
001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
5429b5d9460122fb4b11af9cb88b7bb76d892886...

这都是错的！几个字母字符不正确地大写。请记住，大写是_正确的_校验和的编码。
我们输入的地址的大小写与刚刚计算的校验和不匹配，这意味着地址中的内容发生了变化，并且引入了错误。
