# 《精通以太坊》
## 智能合约
以太坊有两种不同类型的账户：外部所有账户（EOAs）和合约账户。EOAs由以太坊以外的软件（如钱包应用程序）控制。合约帐户由在以太坊虚拟机（EVM）内运行的软件控制。两种类型的帐户都通过以太坊地址标识。
#### 什么是智能合约？
使用术语“智能合约”来指代在Ethereum虚拟机环境中确定性的运行的不可变的计算机程序，该虚拟机作为一个去中心化的世界计算机而运转。
计算机程序：智能合约只是计算机程序。
不可变的：一旦部署，智能合约的代码不能改变。
确定性的：智能合约的结果对于运行它的每个人来说都是一样的，包括调用它们的交易的上下文，以及执行时以太坊区块链的状态。 
EVM上下文：智能合约以非常有限的执行上下文运行。
去中心化的世界计算机：EVM在每个以太坊节点上作为本地实例运行，但由于EVM的所有实例都在相同的初始状态下运行并产生相同的最终状态，因此整个系统作为单台世界计算机运行。
#### 智能合约的生命周期
智能合约通常以高级语言编写，例如Solidity。但为了运行，必须将它们编译为EVM中运行的低级字节码（请参见 [evm]）。一旦编译完成，它们就会随着转移到特殊的合约创建地址的交易被部署到以太坊区块链中。每个合约都由以太坊地址标识，该地址源于作为发起账户和随机数的函数的合约创建交易。合约的以太坊地址可以在交易中用作接收者，可将资金发送到合约或调用合约的某个功能。
重要的是，合约只有被交易调用时才会运行。
执行链中的第一个合约必须始终由EOA的交易调用。合约永远不会“自行”运行，或“在后台运行”。在交易触发执行，直接或间接地作为合约调用链的一部分之前，合约在区块链上实际上是“休眠”的。
交易是 原子性的 atomic，无论他们调用多少合约或这些合约在被调用时执行的是什么。交易完全执行，仅在交易成功终止时记录全局状态（合约，帐户等）的任何更改。成功终止意味着程序执行时没有错误并且达到执行结束。如果交易由于错误而失败，则其所有效果（状态变化）都会“回滚”，就好像交易从未运行一样。失败的交易仍存储在区块链中，并从原始账户扣除gas成本，但对合约或账户状态没有其他影响。
合约的代码不能更改。然而合约可以被“删除”，从区块链上删除代码和它的内部状态（变量）。
删除合约，你需要执行称为 SELFDESTRUCT（以前称为 SUICIDE ）的EVM操作码，该操作码将区块链中的合约移除。该操作花费“负的gas”，从而激励储存状态的释放。
以这种方式删除合约不会删除合约的交易历史（过去），因为区块链本身是不可变的。但它确实会从所有未来的区块中移除合约状态。
#### 以太坊高级语言简介
EVM是一台虚拟计算机，运行一种特殊形式的 机器代码 ，称为_EVM 字节码_，就像计算机CPU运行机器代码x86_64一样。
本节介绍如何编写智能合约以在EVM上运行。

字节码中可以编写智能合约。
大多数以太坊开发人员使用高级符号语言编写程序和编译器，将它们转换为字节码。

智能合约在高度约束和简约的执行环境（EVM）中运行，几乎所有通常的用户界面，操作系统界面和硬件界面都是缺失的。因此，为编程智能合约出现了一些专用语言。

编程语言可以分为两种广泛的编程范式：分别是声明式和命令式，也分别称为“函数式”和“过程式”。
在声明式编程中，我们编写的函数表示程序的 逻辑 logic，而不是 流程 flow。声明式编程用于创建没有 副作用 side effects 的程序，这意味着在函数之外没有状态变化。
声明式编程语言包括Haskell，SQL和HTML等。
命令式编程就是程序员编写一套程序的逻辑和流程结合在一起的程序。命令式编程语言包括例如BASIC，C，C++和Java。
有些语言是“混合”的，这意味着他们鼓励声明式编程，但也可以用来表达一个必要的编程范式。这样的混合体包括Lisp，Erlang，Prolog，JavaScript和Python。
在纯粹的声明式语言中，没有“变量”。
虽然命令式编程更易于编写和读取，并且程序员更常用，但编写按预期方式 准确 执行的程序可能非常困难。程序的任何部分改变状态的能力使得很难推断程序的执行，并引入许多意想不到的副作用和错误。相比之下，声明式编程更难以编写，但避免了副作用，使得更容易理解程序的行为。
智能合约给程序员带来了很大的负担：错误会花费金钱。
最丰富的智能合约语言是命令式的（Solidity）（声明式语言）。
智能合约的高级编程语言包括（年龄排序）：
**LLL**
一种函数式（声明式）编程语言，具有类似Lisp的语法。这是以太坊智能合约的第一个高级语言，但今天很少使用。
**Serpent**
一种过程式（命令式）编程语言，其语法类似于Python。也可以用来编写函数式（声明式）代码，尽管它并不完全没有副作用。很少被使用。最早由Vitalik Buterin创建。
**Solidity**
具有类似于JavaScript，C ++或Java语法的过程式（命令式）编程语言。以太坊智能合约中最流行和最常用的语言。最初由Gavin Wood（本书的合着者）创作。
**Vyper**
最近开发的语言，类似于Serpent，并且具有类似Python的语法。旨在成为比Serpent更接近纯粹函数式的类Python语言，但不能取代Serpent。最早由Vitalik Buterin创建。
**Bamboo**
一种新开发的语言，受Erlang影响，具有明确的状态转换并且没有迭代流（循环）。旨在减少副作用并提高可审计性。非常新，很少使用。
#### 用Solidity构建智能合约
Solidity是编写智能合约的“面向合约的”编程语言。它用于在各种区块链平台上实施智能合约。
Solidity项目的主要“产品”是_Solidity Compiler（solc）_，它将用Solidity语言编写的程序转换为EVM字节码，并生成其他制品，如应用程序二进制接口（ABI）。
Solidity程序可以包含一个+pragma+指令，用于指定与之兼容的Solidity的最小和最大版本，并且可用于编译你的合约。
#### 下载/安装
#### 开发环境
要在Solidity中开发，你可以在命令行上使用任何文本编辑器和+solc+。
使用可以提高生产力的工具。
Solidity程序只是纯文本文件。
虽然花哨的编辑器和开发环境可以让事情变得更容易，但除了简单的文本编辑器（如vim（Linux / Unix），TextEdit（MacOS）甚至NotePad（Windows）），无需任何其他东西。只需将程序源代码保存为+.sol+扩展名即可，Solidity编译器将其识别为Solidity程序。
#### 以太坊合约应用程序二进制接口（ABI）
在计算机软件中，应用程序二进制接口（ABI）是两个程序模块之间的接口；通常，一个在机器代码级别，另一个在用户运行的程序级别。
API以高级的，通常是人类可读的格式将访问定义为“源代码”。因此，ABI是将数据编码到机器码，和从机器码解码数据的主要方式。
在以太坊中，ABI用于编码EVM的合约调用，并从交易中读取数据。
ABI的目的是定义合约中的哪些函数可以被调用，并描述函数如何接受参数并返回数据。
合约ABI的JSON格式由一系列函数描述和事件的数组给出。函数描述是一个JSON对象，它包含`type`，name，inputs，outputs，constant和`payable`字段。事件描述对象具有type，name，inputs 和 anonymous的字段。
#### 选择Solidity编译器和语言版本

Solidity提供了一个_compiler指令_，称为_version pragma_，指示编译器程序需要特定的编译器（和语言）版本。
Pragma指令不会编译为EVM字节码。它们仅由编译器用来检查兼容性。
#### 使用Solidity编程
**数据类型:**
**boolean（bool）**
布尔值, true 或 false, 以及逻辑操作符 ! (not), && (and), || (or), == (equal), != (not equal).
**整数（int/uint）**
有符号 (int) 和 无符号 (uint) 整数，从 u/int8 到 u/int256以 8 bits 递增，没有大小后缀的话，表示256 bits。
**定点数（fixed/ufixed）**
定点数, 定义为 u/fixedMxN，其中 M 是位大小（以8递增），N 是小数点后的十进制数的个数。
**地址**
20字节的以太坊地址。address 对象有 balance (返回账户的余额) 和 transfer (转移ether到该账户) 成员方法。
**字节组数（定长）**
固定大小的字节数组，定义为+bytes1+到+bytes32+。
**字节组数（动态）**
动态大小的字节数组，定义为+bytes+或+string+。
**enum**
枚举离散值的用户定义类型。
**struct**
包含一组变量的用户定义的数据容器。
**mapping**
+key ⇒ value+对的哈希查找表。

除上述数据类型外，Solidity还提供了多种可用于计算不同单位的字面值：
**时间单位**
seconds, minutes, hours, 和 days 可用作后缀，转换为基本单位 seconds 的倍数。
**以太的单位**
wei, finney, szabo, 和 ether 可用作后缀, 转换为基本单位 wei 的倍数。


****
**预定义的全局变量和函数**
****
在EVM中执行合约时，它可以访问一组较小范围内的全局对象。这些包括 block，msg 和 tx 对象。另外，Solidity公开了许多EVM操作码作为预定义的Solidity功能。在本节中，我们将检查你可以从Solidity的智能合约中访问的变量和函数。
**调用交易/消息上下文**
**msg**
+msg+对象是启动合约执行的交易（源自EOA）或消息（源自合约）。它包含许多有用的属性：
**msg.sender**
我们已经使用过这个。它代表发起消息的地址。如果我们的合约是由EOA交易调用的，那么这是签署交易的地址。
**msg.value**
与消息一起发送的以太网值。
**msg.gas**
调用我们的合约的消息中留下的gas量。它已经被弃用，并将被替换为Solidity v0.4.21中的gasleft()函数。
**msg.data**
调用合约的消息中的数据。
**msg.sig**
数据的前四个字节，它是函数选择器。

Note
每当合约调用另一个合约时，msg+的所有属性的值都会发生变化，以反映新的调用者的信息。唯一的例外是在原始+msg+上下文中运行另一个合约/库的代码的 +delegatecall 函数。


**交易上下文**
**tx.gasprice**
发起调用的交易中的gas价格。
**tx.origin**
源自（EOA）的交易的完整调用堆栈。

**区块上下文**
**block**
包含有关当前块的信息的块对象。**block.blockhash(blockNumber)**
指定块编号的块的哈希，直到之前的256个块。已弃用，并使用Solidity v.0.4.22中的+blockhash()+函数替换。**block.coinbase**
当前块的矿工地址。
**block.difficulty**
当前块的难度（Proof-of-Work）。**block.gaslimit**
当前块的区块gas限制。
**block.number**
当前块号（高度）。
**block.timestamp**
矿工在当前块中放置的时间戳，自Unix纪元（秒）开始。

**地址对象**
任何地址（作为输入传递或从合约对象转换而来）都有一些属性和方法：
**address.balance**
地址的余额，以wei为单位。例如，当前合约余额是 address(this).balance。address.transfer(amount)将金额（wei）转移到该地址，并在发生任何错误时抛出异常。我们在+Faucet+示例中的+msg.sender+地址上使用了此函数，msg.sender.transfer()。**address.send(amount)**
类似于前面的+transfer+, 但是失败时不抛出异常，而是返回+false+。**address.call()**
低级调用函数，可以用+value+，data+构造任意消息。错误时返回+false。
**address.delegatecall()**
低级调用函数，保持发起调用的合约的+msg+上下文，错误时返回+false+。

**内置函数**
**addmod, mulmod**
模加法和乘法。例如，addmod(x,y,k) 计算 (x + y) % k。
**keccak256, sha256, sha3, ripemd160**
用各种标准哈希算法计算哈希值的函数。
**ecrecover**
从签名中恢复用于签署消息的地址。


**合约的定义**
Solidity的主要数据类型是_contract_对象，它在我们的+Faucet+示例的顶部定义。与面向对象语言中的任何对象类似，合约是一个包含数据和方法的容器。
Solidity提供了另外两个与合约类似的对象：
**interface**
接口定义的结构与合约完全一样，只不过没有定义函数，它们只是声明。这种类型的函数声明通常被称为 桩 stub，因为它告诉你有关函数的参数和返回值，没有任何实现。它用来指定合约接口，如果继承，每个函数都必须在子类中指定。
**library**
一个库合约是一个只能部署一次并被其他合约使用的合约，使用+delegatecall+方法（见地址对象）。

**函数**
在合约中，我们定义了可以由EOA交易或其他合约调用的函数。在我们的+Faucet+示例中，我们有两个函数：+withdraw+和（未命名的）_fallback_函数。
函数使用以下语法定义：
function FunctionName([parameters]) {public|private|internal|external} [pure|constant|view|payable] [modifiers] [returns (<return types>)]
我们来看看每个组件：
**FunctionName**
定义函数的名称，用于通过交易（EOA），其他合约或同一合约调用函数。每个合约中的一个功能可以定义为不带名称的，在这种情况下，它是_fallback_函数，在没有指定其他函数时调用该函数。fallback函数不能有任何参数或返回任何内容。
**parameters**
在名称后面，我们指定必须传递给函数的参数，包括名称和类型。在我们的+Faucet+示例中，我们将+uint withdraw_amount+定义为+withdraw+函数的唯一参数。

下一组关键字 (public, private, internal, external) 指定了函数的_可见性_：
**public**
Public是默认的，这些函数可以被其他合约，EOA交易或合约内部调用。在我们的+Faucet+示例中，这两个函数都被定义为public。
**external**
外部函数就像public一样，但除非使用关键字this作为前缀，否则它们不能从合约中调用。
**internal**
内部函数只能在合约内部"可见"，不能被其他合约或EOA交易调用。他们可以被派生合约调用（继承的）。
**private**
private函数与内部函数类似，但不能由派生的合约调用（继承的）。
请记住，术语 internal 和 private 有些误导性。公共区块链中的任何函数或数据总是_可见的_，意味着任何人都可以看到代码或数据。以上关键字仅影响函数的调用方式和时机。

下一组关键字（pure, constant, view, payable）会影响函数的行为：
**constant/view**
标记为_view_的函数，承诺不修改任何状态。术语_constant_是_view_的别名，将被弃用。目前，编译器不强制执行_view_修饰器，只产生一个警告，但这应该成为Solidity v0.5中的强制关键字。
**pure**
纯(pure)函数不读写任何变量。它只能对参数进行操作并返回数据，而不涉及任何存储的数据。纯函数旨在鼓励没有副作用或状态的声明式编程。**payable**
payable函数是可以接受付款的功能。没有payable的函数将拒绝收款，除非它们来源于coinbase（挖矿收入）或 作为 SELFDESTRUCT（合约终止）的目的地。在这些情况下，由于EVM中的设计决策，合约无法阻止收款。
**合约构造和自毁**
有一个特殊函数只能使用一次。创建合约时，它还运行 构造函数 constructor function（如果存在），以初始化合约状态。构造函数与创建合约时在同一个交易中运行。构造函数是可选的。


合约的生命周期始于EOA或其他合约的创建交易。如果有一个构造函数，它将在相同的创建交易中调用，并可以在创建合约时初始化合约状态。
合约生命周期的另一端是 合约销毁 contract destruction。合约被称为+SELFDESTRUCT+的特殊EVM操作码销毁。它曾经是+SUICIDE+，但由于该词的负面性，该名称已被弃用。在Solidity中，此操作码作为高级内置函数+selfdestruct+公开，该函数采用一个参数：地址以接收合约帐户中剩余的余额。看起来像这样：
selfdestruct(address recipient);

**函数修饰器**
Solidity提供了一种称为_函数修饰器_的特殊类型的函数。通过在函数声明中添加修饰器名称，可以将修饰器应用于函数。

**合约继承**
Solidity的合约对象支持 继承，这是一种用附加功能扩展基础合约的机制。要使用继承，请使用关键字+is+指定父合约：
contract Child is Parent {
}

通过这个构造，+Child+合约继承了+Parent+的所有方法，功能和变量。Solidity还支持多重继承，可以在关键字+is+之后用逗号分隔的合约名称指定多重继承：
contract Child is Parent1, Parent2 {
}

合约继承使我们能够以实现模块化，可扩展性和重用的方式编写我们的合约。
**错误处理（assert，require，revert）**
合约调用可以终止并返回错误。Solidity中的错误由四个函数处理：assert, require, revert, 和 throw（现在已弃用）。
**事件（Events）**
事件是便于生产交易日志的Solidity构造。当一个交易完成（成功与否）时，它会产生一个 交易收据 transaction receipt，就像我们在 [evm] 中看到的那样。交易收据包含_log_条目，用于提供有关在执行交易期间发生的操作的信息。事件是用于构造这些日志的Solidity高级对象。
**捕捉事件**
事件是一种非常有用的机制，不仅适用于合约内通信，还适用于开发过程中的调试。
##### 安全考虑
防御性编程 _Defensive programming_是一种编程风格，特别适用于智能合约编程，具有以下特点：
**极简/简约**
**代码重用**
**代码质量**
**可读性/可审核性**
**测试覆盖**
