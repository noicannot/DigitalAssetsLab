# 《精通以太坊》

## 交易
交易是由外部所有账户发起的签名消息，由以太坊网络传输，并在以太坊区块链上进行记录（挖掘）。看待交易的另一种方式是，它们是唯一可触发状态更改或导致合约在EVM中执行的东西。以太坊是一个全球的单实例状态机器，交易是唯一可以让状态机“运动”，改变状态的东西。合约不会自行运行。以太坊不会在后台运行。一切都始于交易。

本节刨析交易，展示它们的工作方式，并了解详细信息。
#### 交易的结构
因为它是在以太坊网络上进行序列化和传输的。接收序列化交易的每个客户端和应用程序将使用其自己的内部数据结构将其存储在内存中，还会使用网络序列化交易本身中不存在的元数据进行修饰。交易的网络序列化是交易结构的唯一通用标准。

交易是一个序列化的二进制消息，其中巴汗以下数据：
**nonce**
由始发EOA（外部所有账户）发出的序列号，用于防止消息重播。
**gas price**
发起人愿意支付的gas价格（以wei为单位）。
**start gas**
发起人愿意支付的最大gas量。
**to**
目标以太坊地址。
**value**
发送到目标地址的ether数量。
**data**
变长二进制数据。
**v,r,s**
始发EOA的ECDSA签名的三个组成部分。

交易消息的结构使用递归长度前缀（RLP）编码方案进行序列化，该方案是专门为以太坊中准确和字节完美的数据序列化而创建的。以太坊中的所有数字都被编码为大端序整数，其长度为8位的倍数。
字段的标签（"to",“start gas”等）在这里是为清楚起见而显示，但不是包含字段值的RLP编码交易序列化数据的一部分。通常，RLP不包含任何字段分隔符或标签。RLP的长度前缀用于标识每个字段的长度。因此，超出定义长度的任何内容都属于结构中的下一个字段。
这些数据来源于交易，但不是交易信息本身的一部分。
#### 交易的随机数（nonce）
nonce：与此地址发送的交易数量相等的标量值，或者，对于具有关联代码的账户，表示此账户创建的合约数量。
严格说，nonce来源于此地址的已确认交易的数量动态计算的，而非存储在区块链中。
nonce值防止账户余额的错误计算。nonce强制任何地址的交易按顺序处理。如果一个节点先接收到nonce2的交易，会持有它，但在收到并处理完nonce1的交易之前不会验证它。
#### 跟踪nonce
实际上，nonce是源自账户的已确认（已开采）交易数量的最新计数。
Tip：该nonce是一个基于零的计数器，第一个交易nonce是0.
当构建生成交易的应用程序时，无法依赖getTransactionCount处理未完成的交易。。只有待处理和已确认相同（所有未完成的交易都已确认）时，才能信任getTransactionCount的输出以开始nonce计数器。
Parity的JSON RPC接口提供parity_nextNonce函数，该函数返回应在交易中使用的下一个nonce。
#### nonce的间隔，重复的nonce和确认
如果正在以编程方式创建交易，跟踪nonce是十分重要的，特别是如果同时从多个独立进程执行此操作。
以太坊网络根据nonce顺序处理交易。意味着使用nonce 0 传输一个交易，然后传输一个具有nonce 2的交易，则第二个交易将不会被挖掘。它将存储在mempool中，以太坊网络等待丢失的nonce出现。
交易可以在nonce序列中产生无意的“间隙”，比如因为它无效或gas不足。为了让事情继续进行，必须传输一个具有丢失的nonce的有效交易。
传输具有相同nonce的两个交易，谁先到达第一个接收它们的验证节点的顺序谁被确认。
#### 并发，交易的发起和随机数
简单来说，并发是指多个独立系统同时进行计算。
以太坊是一个允许操作（节点，客户端，DApps）并发的系统，但是强制实施一个单一的状态。
最后，除了跟踪独立进程中的账户余额和交易确认的难度之外，这些并发问题迫使大多数实现朝着避免并发和创建瓶颈进行，诸如单个进程处理交易所中的所有取款交易。
#### 交易gas
gas是以太坊的燃料。它是独立的虚拟货币，有相对于ether的汇率。以太坊使用gas来控制交易可以花费的资源量，避免拒绝服务攻击或无意中的资源吞噬交易。
交易中的gasPrice字段允许交易创建者设置每个单位的gas的汇率。gas价格以每单位gas多少wei测量。
gasPrice越高，交易可能被验证的速度越快。
startGas定义交易发起人愿意花费多少单位完成交易。
如果你的交易的目的地址是合约，则可以估计所需的gas量，但无法准确确定。
以太坊常见类比，将startGas视为汽车中的油箱（汽车为交易）。你认为它需要旅行（验证交易所需的计算），就用尽可能多的gas填满油箱。
交易完成之后支付gas量所需支付的gasPrice* startGas费用。但是发送交易之前，必须有足够的余额用于你愿意支付的最高金额。
#### 交易的接收者
交易的收件人在to字段中指定。20字节的以太坊地址。
Warning以太坊不能也不会验证交易中的接收者地址。你可以发送到没有相应私钥或合约的地址，从而“燃烧”ether，使其永远不会被花费。验证应该在用户界面层级完成。
#### 交易的价值和数据
交易的主要“负载”包含在两个字段中：value 和 data。
交易可以同时具有value和data，只有value，只有data，或没有value和data。所有四种组合都是有效的。

只有value的交易是 支付 payment。只有data的交易是 调用 invocation。既没有value也没有data的交易，这可能只是浪费gas！但它仍然有可能。
#### 将value传递给EOA和合约
当你构建包含 value 的以太坊交易时，它等同于_payment_。

对于EOA地址，以太坊将记录状态更改，并将你发送的value添加到地址的余额中。如果地址之前没有被查看过，则会创建地址并将其余额初始化为你的付款+value+。

如果目标地址（to）是合约，则EVM将执行合约并尝试调用你的交易的 data 中指定的函数（参见 [invocation] ）。如果你的交易中没有 data，那么EVM将调用目标合约的 fallback 函数，如果该函数是payable，则将执行该函数以确定下一步该做什么。

合约可以通过在调用付款功能时立即抛出异常或由付款功能中编码的条件确定来拒绝收款。如果付款功能成功终止（没有意外），则更新合约状态以反映合约的ether余额增加。
#### 将数据传输到EOA或合约
当交易包含+data+时，它很可能是发送到合约地址的。

发送到合约的 data 是一个十六进制序列化的编码：
**函数选择器（function selector）**

函数_prototype_的Keccak256哈希的前4个字节。这使EVM能够明确地识别你希望调用的功能。
**函数参数**
函数的参数，根据EVM定义的各种基本类型的规则进行编码。
#### 特殊交易：合约注册
有一种特殊的带有data，没有value的交易。表示注册一个新的合约。

合约登记交易被发送到一个特殊的目的地地址，即零地址。简而言之，合约注册交易中的+to+字段包含地址 0x0。该地址既不代表EOA（没有相应的私人/公共密钥对）也不代表合约。它永远不会花费ether或启动交易。它仅用作目的地，具有“注册此合约”的特殊含义。

Warning：发送至合约注册地址 0x0 或指定燃烧地址 0x0 ... dEaD 的任何ether将变得不可消费并永远丢失。

#### 数字签名
**椭圆曲线数字签名算法（ECDSA）**
数字签名在以太坊中有三种用途。
首先，签名证明私钥的所有者，暗示着以太坊账户的所有者，已经授权支付ether或执行合约。其次，授权的证明是_undeniable_（不可否认）。第三，签名证明交易数据在交易签名后没有也不能被任何人修改。
**数字签名如何工作**
数字签名是一种数学签名，由两部分组成。第一部分是使用私钥（签名密钥）从消息（交易）中创建签名的算法。第二部分是允许任何人仅使用消息和公钥来验证签名的算法。
**创建数字签名**
在以太坊实现的ECDSA中，被签名的“消息”是交易，或者更确切地说，来自交易的RLP编码数据的Keccak256哈希。签名密钥是EOA的私钥。结果是签名：
\(\(Sig = F_{sig}(F_{keccak256}(m), k)\)\)
其中:
* k是签名私钥_
* m是RLP编码的交易
* Fkeccak256 是Keccak256哈希函数
* Fsig 是签名算法
* Sig 是由此产生的签名

函数 Fsig 产生一个由两个值组成的签名+Sig+，通常称为+R+和+S+：
Sig = (R, S)
#### 验证签名
要验证签名，必须有签名（R+和+S），序列化交易和公钥（与用于创建签名的私钥对应）。实质上，对签名的验证意味着“只有生成此公钥的私钥的所有者才能在此交易上产生此签名。”
签名验证算法采用消息（交易的散列或其部分），签名者的公钥和签名（+R+和+S+值），如果签名对此消息和公钥有效，则返回TRUE。
#### ECDSA数学
签名算法首先生成_ephemeral_（临时的）私钥/公钥对。在涉及签名私钥和交易哈希的转换之后，此临时密钥对用于计算_R_和_S_值。
临时密钥对由两个输入值生成：
1.一个随机数_q_，用作临时私钥 1.和椭圆曲线生成点_G_
从_q_和_G_开始，我们生成相应的临时公钥_Q_（以_Q = q * G_计算，与以太坊公钥的派生方式相同，参见[pubkey]）。数字签名的_R_值就是临时公钥_Q_的x坐标。
验证是签名生成函数的反函数，使用_R_，S_值和公钥来计算一个值_Q，它是椭圆曲线上的一个点（签名创建中使用的临时公钥）
#### 实践中的交易签名
当我们说“签署交易”时，我们实际上是指“签署RLP序列化交易数据的Keccak256哈希”。签名应用于交易数据的哈希，而不是交易本身。
要在以太坊签署交易，发件人必须：
1.创建一个包含九个字段的交易数据结构：nonce，gasPrice，startGas，to，value，data，v，r，s
2.生成交易的RLP编码的序列化消息
3.计算此序列化消息的Keccak256哈希
4.计算ECDSA签名，用发起EOA的私钥签名散列
5.在交易中插入ECDSA签名计算出的 r 和 s 值

#### 原始交易创建和签名
创建一个原始交易并使用 ethereumjs-tx 库对其进行签名。
此示例的源代码位于GitHub存储库中的 raw_tx_demo.js 中。
#### 用EIP-155创建原始交易
EIP-155“简单重播攻击保护”标准在签名之前指定了重播攻击保护（replay-attack-protected）的交易编码，其中包括交易数据中的_chain identifier_。这确保了为一个区块链（例如以太坊主网）创建的交易在另一个区块链（例如Ethereum Classic或Ropsten测试网络）上无效。因此，在一个网络上广播的交易不能在另一个网络上广播，因此得名“重放攻击保护”。
EIP-155向交易数据结构添加了三个字段 v，r+和+s。r+和+s 字段被初始化为零。这三个字段在编码和散列_之前_被添加到交易数据中。因此，三个附加字段会更改交易的散列，稍后将应用签名。通过在被签名的数据中包含链标识符，交易签名可以防止任何更改，因为如果链标识符被修改，签名将失效。因此，EIP-155使交易无法在另一个链上重播，因为签名的有效性取决于链标识符。
#### 签名前缀值（v）和公钥恢复
如交易的结构所述，交易消息不包含任何“from”字段。
给定 ECDSA数学 中计算的值 r 和 s，我们可以计算两个可能的公钥。
首先，我们根据签名中的x坐标 r 值计算两个椭圆曲线点R和R'。有个两点，因为椭圆曲线在x轴上是对称的，所以对于任何值+x+，在x轴的两侧有两个可能的值适合曲线。
从 r 开始，我们也计算r-1这是 r 的倒数。
最后我们计算 z，它是消息散列的最低位，其中n是椭圆曲线的阶数。

为了使事情更有效率，交易签名包括一个前缀值 v，它告诉我们两个可能的R值中哪一个是临时的公钥。如果 v 是偶数，那么R是正确的值。如果 v 是奇数，那么选择R'。这样，我们只需要计算R的一个值。
#### 分离签名和传输（离线签名）
一旦交易被签署，它就可以传送到以太坊网络。
创建，签署和广播交易的三个步骤通常发生在单个函数中，例如使用+web3.eth.sendTransaction+。
分离签名和传输功能称为 离线签名offline signing，是一种常见的安全措施。

在气隙系统中根本没有网络连接 - 计算机与在线环境是“空气”隔离的。使用数据存储介质或（更好）网络摄像头和QR码将交易记录到气隙计算机上，以签署交易。当然，这意味着必须手动传输你想要签名的每个交易，不能批量化。
#### 交易传播
以太坊网络使用“泛洪”路由协议。每个以太坊客户端，在_Peer-to-Peer（P2P）中作为_node，（理想情况下）构成_mesh_网络。没有网络节点是“特殊的”，它们都作为平等的对等体。我们将使用术语“节点”来指代连接并参与P2P网络的以太坊客户端。
交易传播开始于创建（或从离线接收）签名交易的以太坊节点。
#### 记录到区块链中
有效的交易最终将被包含在一个交易块中，并记录在以太坊区块链中。一旦开采成块，交易还通过修改账户余额（在简单付款的情况下）或通过调用改变其内部状态的合约来修改以太坊单例的状态。这些更改将与交易一起以交易_收据_ receipt 的形式记录，该交易也可能包含_事件_ events。
#### 多重签名（multisig）交易
比特币的脚本功能，可能创建一个比特币多重签名账户，该账户只能在多方签署交易时花费资金（例如2个或3个或4个签名）。以太坊的价值交易没有多重签名的规定，尽管可以部署任意条件的任意合约来处理ether和代币的转让。

为了在多重签名情况下保护你的ether，将它们转移到多重签名合约中。无论何时你想将资金转入其他账户，所有必需的用户都需要使用常规钱包软件将交易发送至合约，从而有效授权合约执行最终交易。
这些合约也可以设计为在执行本地代码或触发其他合约之前需要多个签名。该方案的安全性最终由多重签名合约代码确定。
