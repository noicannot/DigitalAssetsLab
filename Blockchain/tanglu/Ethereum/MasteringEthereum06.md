# 《精通以太坊》
## 钱包
在以太坊中，“钱包”一词有几个不同的含义。
较高层次上，钱包是作为主要用户界面的应用程序。
一些以太坊钱包还可以与合约（如代币）进行交互。
狭义上讲，从程序员角度来看，“钱包”一词是指用于存储和管理用户密钥的系统。每个“钱包”都有一个密钥管理组件。其他一些钱包是更广泛类别的一部分，即“浏览器”，它是以太坊去中心化应用或“DApps”的接口。

本节中，把钱包看作私钥的容器，并将其视为用于管理密钥的系统。
#### 钱包技术概览
本节总结，用于构建用户友好，安全和灵活的以太坊钱包的技术。
以太坊的误解是以太坊钱包包含ether或代币。实际上，钱包只包含密钥。ether或其他代币记录在以太坊区块链中。用户通过使用钱包中的密钥签署交易来控制网络上的代币。从某种意义上说，以太坊钱包是一个钥匙串keychain。

Tip 以太坊钱包包含密钥，而不是ether或令牌。钱包是包含私钥/公钥的钥匙串。用户使用密钥签署交易，从而证明他们拥有ether。ether储存在区块链上。

有两种主要类型的钱包，通过它们包含的密钥是否彼此相关来区分。
第一种类型是非确定性钱包nondeterministic wallet，其中每个密钥都是从随机数中独立生成的。密钥不相互关联。这种类型的钱包也被称为“Just a Bunch Of Keys”，JBOK钱包。
第二种类型的钱包是确定性钱包deterministic wallet，其中所有密钥都来自单个主密钥，称为种子seed。这种类型的钱包中的所有钥匙都是相互关联的，如果有原始种子，可以再次生成。确定性钱包中使用了许多不同的密钥推导方法。最常用的派生方法使用树状结构，称为分层确定hierarchical deterministic或HD钱包。

确定性钱包是从种子初始化的。为了使这些更容易使用，种子被编码为一些英文单词（或其他语言的词），称为mnemonic code助记词。
接下来的几节将从较高的层次介绍这些技术。
####  非确定性（随机）钱包
在第一个以太坊钱包（由Ethereum pre-sale创建）中，钱包文件存储一个随机生成的私钥。这些钱包正在被确定性钱包取代，因为它们管理，备份和导入很麻烦。随机密钥的缺点是，如果你生成了许多密钥，你必须保留所有密钥的副本。每个密钥都必须备份，否则如果钱包变得不可访问，则其控制的资金将不可撤销地丢失。此外，以太坊地址重用可以通过将多个交易和地址相互关联来降低隐私。0型非确定性钱包是很少的选择，特别是如果你想避免地址重用，因为它意味着管理许多密钥，需要经常备份。
以太坊客户端（包括go-ethereum或geth）使用keystore文件，这是一个JSON编码的文件，其中包含一个（随机生成的）私钥，由一个密码加密以提高安全性。
keystore格式使用Key派生函数（KDF），也称为密码扩展算法，该算法可防止对密码加密的暴力破解，字典或彩虹表攻击。简而言之，私钥没有直接由密码短语加密。相反，通过反复对它进行哈希，密码被拉长。哈希函数重复执行262144轮。试图暴力破解密码短语的攻击者必须对每个尝试的密码应用262144轮哈希，这足以减缓攻击行为，从而使破解足够复杂性和够长的密码短语是不可行的。
有许多软件库可以读写keystore格式，例如javascript库keythereum
Tip 除简单测试以外，不鼓励使用非确定性钱包，他们太麻烦了，无法备份和使用。使用具有mnemonic种子的基于行业标准的HD钱包。
#### 确定性（种子）钱包
确定性或“种子”钱包是包含私钥的钱包，所有私钥都来源于共同的种子，使用单向哈希函数生成。种子是随机生成的数字，可以与其他数据组合以导出私钥。在确定性钱包中，种子足以恢复所有派生的密钥，因此在创建时的单个备份就足够了。种子也足以用于钱包的导入和导出，允许在不同实现的钱包之间轻松迁移所有用户密钥。

#### HD钱包（BIP-32/BIP-44）
确定性钱包的最先进的形式是由比特币的BIP-32标准定义的HD钱包。树状结构可以达到无限深度。
与随机（非确定性）密钥相比，HD钱包具有两大优势。首先，树状结构可以用来表达额外的组织含义，例如，使用特定分支的子密钥来接收传入的支付，使用不同分支的子密钥来接收支付时产生的零钱。密钥的分支也可用于公司设置，将不同分支分配给部门，子公司，特定职能或会计类别。
HD钱包的第二个优点是用户可以创建一系列公钥而无需访问相应的私钥。这允许HD钱包用于不安全的服务器上，或者仅用于只查看或只接收的地方，其中钱包没有可以花费资金的私钥。

#### 种子和助记词（BIP-39）
HD钱包是管理许多密钥和地址的非常强大的机制。它们与一系列英文单词相结合，更易于转录和跨钱包的导出导入。这被称为mnemonic，标准由BIP-39定义。并且可以使用可互操作的助记词导入和导出种子以进行备份和恢复。
#### 钱包最佳实践
允许钱包从多个不同的加密货币中获取密钥，所有这些都来自助记词。这些通用标准是：
* 基于BIP-39的助记词
* 基于BIP-32的HD钱包
* 基于BIP-43的多用途HD钱包
* 基于BIP-44的多币种和多账户钱包
这些标准可能会改变，但现在已成为大多数加密货币的事实上的钱包标准。
用户可以导出其中一个钱包上生成的助记词并将其导入另一个钱包，恢复所有交易，密钥和地址。
支持这些标准的软件钱包有Jaxx，MetaMask，MyEtherWallet（MEW），硬件钱包有：Keepkey，Ledger和Trezor。
TIP 如果正在实现以太坊钱包，则应该将其作为HD钱包构建，并将种子编码为易于备份的助记词，并遵循BIP-32,BIP-39,BIP-43和BIP-44标准。
##### 助记词（BIP-39）
助记词是表示（编码）派生确定性钱包的种子的随机数的单词序列。单词序列足以重新创建种子，从而重新创建钱包和所有派生的密钥。使用助记词实现的确定性钱包会在首次创建钱包时向用户展示12至24个字的序列。该单词序列是钱包的备份，可用于在相同或任何兼容的钱包应用程序中恢复和重新创建所有密钥。

Tip 助记词经常与“脑钱包”混淆。主要区别在于脑钱包由用户选择的单词组成，而助记词由钱包随机创建并呈现给用户。助记词更加安全。
BIP-39可用于生产支持以太坊的多币种钱包，而Electrum种子不能。
##### 生成助记词
助记词是由钱包使用BIP-39中定义的标准化流程自动生成的。钱包从熵源开始，添加校验和，然后将熵映射到单词列表：

1.创建一个128到256位的随机序列（熵）。
2.通过取其SHA256哈希的第一部分（熵长度/32）来创建随机序列的校验和。
3.将校验和添加到随机序列的末尾。
4.将序列按照11bits划分。
5.将每个11bits的值映射到预定义字典中的2048个词中的一个。
6.助记词就是单词的序列。
![img](https://github.com/noicannot/DigitalAssetsLab/blob/main/Blockchain/tanglu/Ethereum/Mnemonic%20Words%20128-bit%20entrop.jpg)

Mnemonic codes：entropy and word length展示熵数据的大小和助记词的长度关系。

Table 1. Mnemonic codes: entropy and word length
![img](https://github.com/noicannot/DigitalAssetsLab/blob/main/Blockchain/tanglu/Ethereum/Mnemonic%20to%20Seed.jpg)
##### 从助记词到种子

助记符字表示长度为128到256位的熵。然后使用密钥扩展函数PBKDF2将熵导出成更长的（512位）种子。然后使用生成的种子构建确定性钱包并派生其密钥。
密钥扩展函数有两个参数：助记词和salt。在密钥扩展函数中使用盐的目的是使得构建能够进行暴力攻击的查找表不可行。在BIP-39标准中，盐有另一个目的——它允许引入密码，作为保护种子的附加安全因素。

步骤7到9中从 生成助记词 描述的过程后继续：

7.PBKDF2密钥扩展函数的第一个参数是步骤6产生的助记词。
8.PBKDF2密钥扩展函数的第二个参数是盐。盐由用户提供的密码字符串和“mnemonic”组合起来。
9.PBKDF2使用2048轮HMAC-SHA512哈希算法，扩展助记词和盐，生成512位的种子。

展示如何使用助记词来生成种子。
![66201ebfcb505553f643e47f46e972f8.png](en-resource://database/909:1)
Tip 密钥扩展函数及其2048轮哈希对抵御助记词或密码攻击具有一定的有效保护作用。它使（在计算机中）尝试超过几千个密码和助记词组合的成本高昂，因为可能派生的种子数量很大（2的512次方）。

##### BIP-39中的可选密码短语
BIP-39标准允许在派生种子时使用可选的密码短语。如果没有使用密码短语，助记词将被一个由常量字符串+“mnemonic”+组成的盐扩展，从任何给定的助记词中产生一个特定的512位种子。如果使用密码短语，则扩展函数会从同一助记词中生成一个不同的种子。事实上，对于一个助记符，每个可能的密码都会生成不同的种子。本质上，没有“错误的”密码。所有密码都是有效的，它们都会生成不同的种子，形成一大批可能未初始化的钱包。可能的钱包的集合非常大（2的512次方），因此没有暴力或意外猜测正在使用的钱包的可能。

Tip BIP-39中没有“错误”的密码短语。每个密码都会生成一些空钱包，除非以前使用过。
可选的密码短语创造了两个重要的特性：
* 第二个使得只有助记词没有用的因素（需要记忆的东西），从而保护助记词备份免受小偷的威胁。
* 一种似是而非的拒绝形式或“胁迫钱包”，一个选定的密码短语会导致一个带有少量资金的钱包，用于将攻击者从包含大部分资金的“真实”钱包吸引开。
但是，重要的是要注意使用密码也会导致丢失的风险。
* 如果钱包所有者无行为能力或死亡，且其他人不知道密码，则种子无用，钱包中存储的所有资金将永远丢失。
* 相反，如果所有者在与种子相同的位置备份密码，它会失去第二个因素的目的。
虽然密码短语非常有用，但只能结合精心策划的备份和恢复过程，考虑到主人存活的可能性，并允许其家人恢复加密货币资产。
##### 使用助记词
BIP-39以许多不同的编程语言实现为库：
**python-mnemonic**
SatoshiLabs团队提出的BIP-39标准的参考实现，使用Python
**Consensys/eth-lightwallet**
轻量级JS Ethereum节点和浏览器钱包（使用BIP-39）
**npm/bip39**
比特币BIP39的JavaScript实现：用于生成确定性密钥的助记词

##### 从种子创建HD钱包
HD钱包是由单个根种子创建的，该种子是128，256或512位随机数。最常见的情况是，这个种子是从助记词生成的。

HD钱包中的每个密钥都是从这个根种子确定性地派生出来的，这使得可以在任何兼容的HD钱包中从该种子重新创建整个HD钱包。这使得备份，恢复，导出和导入包含数千乃至数百万个密钥的HD钱包变得很容易，只需传输根种子的助记词即可。

**Consensys/eth-lightwallet**
轻量级JS Ethereum节点和浏览器钱包（使用BIP-32）

Note 
独立的BIP-32生成器不是HTTPS网站。提醒你，使用这个工具是不安全的。它仅用于测试。你不应使用本网站制作的密钥（使用实际资金）。

**扩展公钥和私钥**

在BIP-32术语中，可以扩展并产生“孩子”的父密钥称为 扩展密钥 extended key。如果它是一个私有密钥，它是由前缀_xprv_区分的 扩展私钥 extended_private_key：

xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8imbZKLYVBxFPND1pniTZ81vKfd45EHKX73

扩展公钥 extended public key 由前缀 xpub 区分:
xpub661MyMwAqRbcEnKbXcCqD2GT1di5zQxVqoHPAgHNe8dv5JP8gWmDproS6kFHJnLZd23tWevhdn4urGJ6b264DfTGKr8zjmYDjyDTi9

HD钱包的一个非常有用的特点是能够从公开的父公钥中派生子公钥，而不需要拥有私钥。这为我们提供了两种派生子公钥的方法：从子私钥派生，或直接从父公钥派生。
##### 强化子密钥派生
从xpub派生公钥的分支是非常有用的，但它带有潜在风险。访问xpub不能访问子私钥。xpub包含链码，子私钥和链码一起使用，以派生所有其他子私钥。更糟糕的是，可以使用子私钥和父链码来推导父私钥。
为了应对这种风险，HD钱包使用一种称为 强化派生 _hardened derivation_的替代派生函数，该函数“破坏”父公钥和子链码之间的关系。强化派生函数使用父私钥来派生子链码，而不是父公钥。这会在父/子序列中创建一个“防火墙”，链码不能用于危害父代或同级私钥。

最佳做法，主密钥的1级子密钥级始终通过强化派生，以防止主密钥受到破坏。
**正常和强化派生的索引号**

BIP-32派生函数中使用的索引号是一个32位整数。为了便于区分通过常规派生函数派生的密钥与通过强化派生函数派生的密钥，该索引号分为两个部分。0到231-1（0x0到0x7FFFFFFF）之间的索引号仅用于常规派生。231和232-1（0x80000000至0xFFFFFFFF）之间的索引号仅用于强化派生。因此，如果索引号小于231，则子项是常规的，如果索引号等于或大于231，则子项是强化的。

为了使索引号更容易阅读和展示，强化子项的索引号从零开始展示，但带有一个主要符号。第一个正常子密钥展示为0，而第一个强化子密钥（索引0x80000000）展示为0'。然后，按顺序，第二个强化子密钥将具有索引0x80000001，并将展示为1'，依此类推。当你看到HD钱包索引i'时，表示231+i。

**HD钱包密钥标识符（路径）**

HD钱包中的密钥使用“路径”命名约定来标识，树的每个级别都用斜杠（/）字符分隔。
从主密钥派生的私钥以“m”开头。从主公钥派生的公钥以“M”开始。因此，主私钥的第一个子私钥为m/0。第一个子公钥是M/0。第一个孩子的第二个孩子是m/0/1，依此类推。
从右向左读取一个密钥的“祖先”，直到你到达从派生出它的主密钥。
例如，标识符 m/x/y/z 描述了密钥 m/x/y 的第z个子密钥，密钥 m/x/y 是密钥 m/x 的第y个子密钥，密钥 m/x 是 m 的第 x 个子密钥。
**HD钱包树状结构导航**

HD钱包树结构提供了巨大的灵活性。每个父扩展密钥可以有40亿子密钥：20亿正常子密钥和20亿强化子密钥。这些子密钥中的每一个又可以有另外40亿子密钥，以此类推。这棵树可以像你想要的一样深，无限的世代。然而，这些灵活性，使得在这个无限树中导航变得非常困难。在实现之间转移HD钱包尤其困难，因为内部组织分支和子分支的可能性是无穷无尽的。
通过为HD钱包的树状结构创建一些标准，两个BIP为这种复杂性提供了解决方案。BIP-43建议使用第一个强化子密钥作为表示树结构“目的”的特殊标识符。基于BIP-43，HD钱包应该只使用树的一个1级分支，索引号通过定义其目的来标识树的其余部分的结构和名称空间。例如，仅使用分支m/i'/的HD钱包表示特定目的，而该目的由索引号“i”标识。

扩展该规范，BIP-44提出了一个多币种多帐户结构作为BIP-43下的“目的”号码+44'+。遵循BIP-44的HD钱包通过仅使用树的一个分支的事实来标识：m / 44'/。
BIP-44指定了包含五个预定义层级的结构
m / purpose' / coin_type' / account' / change / address_index

第一级“purpose”始终设置为+44'+。第二级“coin_type”指定加密货币类型，允许多货币HD钱包，其中每种货币在第二级下具有其自己的子树。标准文件中定义了几种货币，称为SLIP0044：

树的第三层“account”, 允许用户将他们的钱包分割成逻辑上的子账户，用于会计或组织管理目的。例如HD钱包可能包含两个以太坊“账户”： m/44'/60'/0' 和 m/44'/60'/1'. 每个账户都是自己的子树的根。
由于BIP-44最初是为比特币创建的，因此它包含一个在以太坊世界中不相关的“怪癖”。在路径的第四层“change”时，HD钱包有两个子树，一个用于创建接收地址，另一个用于创建零钱地址。以太坊只使用“接收”路径，因为没有零钱地址这样的东西。请注意，虽然以前的层级使用强化派生，但此层级使用正常派生。这是为了允许树的这个层级导出扩展公钥在非安全环境中使用。可用地址由HD钱包作为第四级的孩子派生，使树的第五级成为“address_index”。例如，在主账户中以太坊付款的第三个接收地址为M/44'/60'/0'/0/2。BIP-44 HD wallet structure examples 展示了几个例子。
![d12ef87adeb2409a300c5f0810c12f20.png](en-resource://database/911:1)
